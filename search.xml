<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CentOS7 安装Docker-ce</title>
      <link href="/2019/03/21/centos7-install-docker-ce/"/>
      <url>/2019/03/21/centos7-install-docker-ce/</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS7-安装Docker-ce"><a href="#CentOS7-安装Docker-ce" class="headerlink" title="CentOS7 安装Docker-ce"></a>CentOS7 安装Docker-ce</h1><p>从2017年3月开始 docker 在原来的基础上分为两个分支版本: Docker CE 和 Docker EE。<br>Docker CE 即社区免费版，Docker EE 即企业版，强调安全，但需付费使用。<br>本文介绍 Docker-ce的安装使用。</p><h4 id="移除旧的版本"><a href="#移除旧的版本" class="headerlink" title="移除旧的版本"></a>移除旧的版本</h4><pre><code>$ sudo yum remove docker \              docker-client \              docker-client-latest \              docker-common \              docker-latest \              docker-latest-logrotate \              docker-logrotate \              docker-selinux \              docker-engine-selinux \              docker-engine</code></pre><h4 id="安装一些必要的系统工具"><a href="#安装一些必要的系统工具" class="headerlink" title="安装一些必要的系统工具"></a>安装一些必要的系统工具</h4><pre><code>$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre><h4 id="添加软件源信息"><a href="#添加软件源信息" class="headerlink" title="添加软件源信息"></a>添加软件源信息</h4><pre><code>$ sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre><h4 id="更新-yum-缓存"><a href="#更新-yum-缓存" class="headerlink" title="更新 yum 缓存"></a>更新 yum 缓存</h4><pre><code>$ sudo yum makecache fast</code></pre><h4 id="查看可用版本的-Docker-ce"><a href="#查看可用版本的-Docker-ce" class="headerlink" title="查看可用版本的 Docker-ce"></a>查看可用版本的 Docker-ce</h4><pre><code>$ yum list docker-ce --showduplicates | sort -r</code></pre><blockquote><p>注意：如果需要只显示table版本，可以关闭测试版本的list：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> yum-config-manager --enable docker-ce-edge$ <span class="token function">sudo</span> yum-config-manager --enable docker-ce-test</code></pre></blockquote><h4 id="更新yum包索引"><a href="#更新yum包索引" class="headerlink" title="更新yum包索引"></a>更新yum包索引</h4><pre><code>$ yum makecache fast</code></pre><h4 id="安装指定版本的docker-ce"><a href="#安装指定版本的docker-ce" class="headerlink" title="安装指定版本的docker-ce"></a>安装指定版本的docker-ce</h4><pre><code>$ sudo yum install -y docker-ce-17.03.2.ce-1.el7.centos </code></pre><blockquote><p>报错：如果在安装指定版本的docker时显示需要安装指定版本的docker-ce-selinux依赖包，请安装：</p><pre class=" language-bash"><code class="language-bash">$ yum <span class="token function">install</span> -y https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-selinux-17.03.2.ce-1.el7.centos.noarch.rpm </code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat8配置APR模式</title>
      <link href="/2018/12/14/tomcat-apr/"/>
      <url>/2018/12/14/tomcat-apr/</url>
      
        <content type="html"><![CDATA[<h3 id="tomcat三种模式"><a href="#tomcat三种模式" class="headerlink" title="tomcat三种模式"></a>tomcat三种模式</h3><p>Tomcat Connector运行有三种模式：</p><ul><li><p><strong>bio</strong><br>默认的模式,同步阻塞，性能非常低下,没有经过任何优化处理和支持.</p></li><li><p><strong>nio</strong><br>同步非阻塞，利用java的异步io护理技术,noblocking IO技术,想运行在该模式下，直接修改server.xml里的Connector节点,修改protocol为<code>protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</code> 启动后,就可以生效。</p></li><li><p><strong>apr</strong><br>安装起来最困难,但是从操作系统级别来解决异步的IO问题,大幅度的提高性能. Tomcat apr也是在Tomcat上运行高并发应用的首选模式。必须要安装apr、apr-util和native，nio修改模式，修改protocol为 <code>org.apache.coyote.http11.Http11AprProtocol</code> ，直接启动就支持apr。</p></li></ul><h3 id="安装配置APR模式"><a href="#安装配置APR模式" class="headerlink" title="安装配置APR模式"></a>安装配置APR模式</h3><p><strong>本文所有步骤的前提是已经可以正常运行tomcat程序，JDK已安装的环境。</strong></p><p>Tomcat配置apr模式依赖以下包,（ <code>版本根据自己需求选择</code> ）</p><pre><code>apr-1.6.2apr-util-1.6.0openssl-1.0.2l</code></pre><h4 id="下载依赖包"><a href="#下载依赖包" class="headerlink" title="下载依赖包"></a>下载依赖包</h4><pre class=" language-bash"><code class="language-bash">$ <span class="token function">wget</span> http://mirror.bit.edu.cn/apache//apr/apr-1.6.2.tar.gz$ <span class="token function">wget</span> http://mirror.bit.edu.cn/apache//apr/apr-util-1.6.0.tar.gz$ <span class="token function">wget</span> https://www.openssl.org/source/openssl-1.0.2l.tar.gz</code></pre><h4 id="安装各个依赖包"><a href="#安装各个依赖包" class="headerlink" title="安装各个依赖包"></a>安装各个依赖包</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#安装apr</span>$ <span class="token function">tar</span> zxvf apr-1.6.2.tar.gz$ <span class="token function">cd</span> apr-1.6.2$ ./configure --prefix<span class="token operator">=</span>/usr/local/apr <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span><span class="token comment" spellcheck="true">#安装apr-util</span>$ <span class="token function">tar</span> zxvf apr-util-1.6.0.tar.gz$ <span class="token function">cd</span> apr-util-1.6.0$ ./configure --prefix<span class="token operator">=</span>/usr/local/apr-util --with-apr<span class="token operator">=</span>/usr/local/apr <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span><span class="token comment" spellcheck="true">#安装openss-1.0.2l</span>$ <span class="token function">tar</span> zxvf openssl-1.0.2l.tar.gz$ <span class="token function">cd</span> openssl-1.0.2l$ ./config --prefix<span class="token operator">=</span>/usr/local/openssl shared zlib <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span></code></pre><p><em>1、安装apr-util前请确认是否安装了 <code>expat-devel</code> 包，如没安装请安装，不然会报错。<code>yum install expat-devel</code> </em></p><p><em>2、检查openssl是否安装成功 <code>/usr/local/openssl/bin/openssl version -a</code>  显示1.0.2l版本为成功</em></p><h4 id="安装tomcat-native"><a href="#安装tomcat-native" class="headerlink" title="安装tomcat-native"></a>安装tomcat-native</h4><pre class=" language-bash"><code class="language-bash">$ <span class="token function">tar</span> zxvf /usr/local/tomcat8/bin/tomcat-native.tar.gz$ <span class="token function">cd</span> /usr/local/tomcat8/bin/tomcat-native-1.2.12-src/native$ ./configure --with-apr<span class="token operator">=</span>/usr/local/apr --with-java-home<span class="token operator">=</span>/usr/local/java8/ --with-ssl<span class="token operator">=</span>/usr/local/openssl/ <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span></code></pre><h4 id="配置tomcat支持apr配置apr库文件"><a href="#配置tomcat支持apr配置apr库文件" class="headerlink" title="配置tomcat支持apr配置apr库文件"></a>配置tomcat支持apr配置apr库文件</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#方式1：配置坏境变量：</span>$ <span class="token keyword">echo</span> <span class="token string">"export LD_LIBRARY_PATH=<span class="token variable">$LD_LIBRARY_PATH</span>:/usr/local/apr/lib"</span> <span class="token operator">>></span> /etc/profile$ <span class="token keyword">echo</span> <span class="token string">"export LD_RUN_PATH=<span class="token variable">$LD_RUN_PATH</span>:/usr/local/apr/lib"</span> <span class="token operator">>></span> /etc/profile <span class="token operator">&amp;&amp;</span> <span class="token function">source</span> /etc/profile<span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#方式2：catalina.sh脚本文件：在注释行# Register custom URL handlers下添加一行 </span>$ JAVA_OPTS<span class="token operator">=</span><span class="token string">"<span class="token variable">$JAVA_OPTS</span> -Djava.library.path=/usr/local/apr/lib"</span></code></pre><h4 id="修改tomcat-server-xml文件"><a href="#修改tomcat-server-xml文件" class="headerlink" title="修改tomcat server.xml文件"></a>修改tomcat server.xml文件</h4><pre><code> &lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;</code></pre><h4 id="启动Tomcat"><a href="#启动Tomcat" class="headerlink" title="启动Tomcat"></a>启动Tomcat</h4><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> /usr/local/tomcat8/bin$ ./startup.sh</code></pre><h4 id="查看Tomcat模式运行"><a href="#查看Tomcat模式运行" class="headerlink" title="查看Tomcat模式运行"></a>查看Tomcat模式运行</h4><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> /usr/local/tomcat8/logs/catalina.out</code></pre><blockquote><p>如果有显示<code>[http-apr-8080]</code> 说明配置APR模式成功。</p></blockquote><h3 id="java-net-ConnectException异常处理"><a href="#java-net-ConnectException异常处理" class="headerlink" title="java.net.ConnectException异常处理"></a>java.net.ConnectException异常处理</h3><p>有时候在安装完tomcat后，停止tomcat会的会有如下异常，该异常可能和JDK有关系。<br><img src="/images/pic/tomcat1.png" alt></p><p>解决办法：进入JDK目录，编辑java.security文件,(<code>注释掉原来的securerandom.source行，新增此行，保存即可</code> )</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">vi</span> /usr/local/java8/jre/lib/security/java.securitysecurerandom.source<span class="token operator">=</span>file:/dev/./urandom</code></pre>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitlab-CE社区版安装</title>
      <link href="/2018/11/29/install-gitlab-ce/"/>
      <url>/2018/11/29/install-gitlab-ce/</url>
      
        <content type="html"><![CDATA[<p>常见的git环境有git web版和gitolite版本，gitolite权限控制强大，但功能不完善，而git web(gitlab)虽然权限没有像gitolite分的那么细，但是功能异常强大，不仅支持SSH KEY、web密码方式还有CI/CD，PIPELINE功能。所以下文将介绍如何在公司内网搭建私有的gitlab环境。</p><blockquote><p>GitLab官网强烈建议安装Omnibus软件包，因为它安装更快，更易于升级，并且包含增强其他方法所没有的可靠性的功能。我们还强烈建议<code>至少4GB</code>的可用内存` 来运行GitLab。</p></blockquote><h2 id="GitLab的安装"><a href="#GitLab的安装" class="headerlink" title="GitLab的安装"></a>GitLab的安装</h2><h3 id="Omnibus方式安装"><a href="#Omnibus方式安装" class="headerlink" title="Omnibus方式安装"></a>Omnibus方式安装</h3><h5 id="安装并配置必要的依赖项"><a href="#安装并配置必要的依赖项" class="headerlink" title="安装并配置必要的依赖项"></a>安装并配置必要的依赖项</h5><p>在CentOS 7（和RedHat / Oracle / Scientific Linux 7）上，执行以下命令。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> yum <span class="token function">install</span> -y curl policycoreutils-python openssh-server</code></pre><h5 id="更新GitLab国内yum源"><a href="#更新GitLab国内yum源" class="headerlink" title="更新GitLab国内yum源"></a>更新GitLab国内yum源</h5><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> <span class="token operator">></span> /etc/yum.repos.d/gitlab-ce.repo <span class="token operator">&lt;&lt;</span> <span class="token string">EOF[gitlab-ce]name=Gitlab CE Repositorybaseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el<span class="token variable">$releasever</span>/gpgcheck=0enabled=1 EOF</span></code></pre><h5 id="安装GitLab-CE包"><a href="#安装GitLab-CE包" class="headerlink" title="安装GitLab-CE包"></a>安装GitLab-CE包</h5><pre class=" language-bash"><code class="language-bash">$ yum makecache$ yum <span class="token function">install</span> gitlab-ce -y</code></pre><h5 id="配置GitLab-CE域名和邮件通知"><a href="#配置GitLab-CE域名和邮件通知" class="headerlink" title="配置GitLab-CE域名和邮件通知"></a>配置GitLab-CE域名和邮件通知</h5><p>配置文件为<code>/etc/gitlab/gitlab.rb</code> </p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#修改external_url 为你gitlab的访问域名</span>$ vim /etc/gitlab/gitlab.rbexternal_url <span class="token string">'http://git.ipyker.com'</span><span class="token comment" spellcheck="true">#添加gitlab邮件通知配置（大约在/etc/gitlab/gitlab.rb文件的517行）</span>gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_enable'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span> gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_address'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"smtp.ipyker.com"</span>gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_port'</span><span class="token punctuation">]</span> <span class="token operator">=</span> 465gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_user_name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"gitlab@ipyker.com"</span>gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_password'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"mypasswd"</span>gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_authentication'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"login"</span>gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_enable_starttls_auto'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span> gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_tls'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span> gitlab_rails<span class="token punctuation">[</span><span class="token string">'gitlab_email_from'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'gitlab@ipyker.com'</span>gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_domain'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"ipyker.com"</span></code></pre><blockquote><p><strong>GitLab安装完后，工作目录默认为：/var/opt/gitlab、/opt/gitlab，配置文件目录为：/etc/gitlab</strong></p></blockquote><h4 id="GitLab管理"><a href="#GitLab管理" class="headerlink" title="GitLab管理"></a>GitLab管理</h4><h5 id="重载配置信息"><a href="#重载配置信息" class="headerlink" title="重载配置信息"></a>重载配置信息</h5><pre><code>$ gitlab-ctl reconfigure</code></pre><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><pre><code>$ gitlab-ctl start</code></pre><h5 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h5><pre><code>$ gitlab-ctl stop</code></pre><h5 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h5><pre><code>$ gitlab-ctl restart</code></pre><h4 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h4><p>第一次用域名登录gitlab，需要为root用户修改密码，root用户也是gitlab的超级管理员，gitlab也支持修改中文界面，如下图所示<br><img src="/images/pic/welcome-gitlab.png" alt></p><p><img src="/images/pic/language.png" alt></p><p><strong>更多关于gitlab配置信息参数，请参考官网<a href="https://docs.gitlab.com/omnibus/settings/README.html" target="_blank" rel="noopener">GitLab配置文件</a></strong></p><hr><h3 id="Docker方式安装"><a href="#Docker方式安装" class="headerlink" title="Docker方式安装"></a>Docker方式安装</h3><h4 id="GitLab-docker-镜像"><a href="#GitLab-docker-镜像" class="headerlink" title="GitLab docker 镜像"></a>GitLab docker 镜像</h4><p>gitlab-ce镜像存放在<a href="https://hub.docker.com/r/gitlab/gitlab-ce/" target="_blank" rel="noopener">docker官方仓库</a>中。</p><p>GitLab Docker镜像是GitLab的单个镜像，在单个容器上运行所有必要的服务。<br>在以下示例中，我们使用GitLab CE的镜像。如果要使用最新的RC映像，请使用<code>gitlab/gitlab-ce:rc</code> 用于GitLab CE<br>GitLab Docker镜像可以多种方式运行：</p><ul><li><a href="https://docs.gitlab.com/omnibus/docker/#run-the-image" target="_blank" rel="noopener">在Docker Engine中运行映像</a></li><li><a href="https://docs.gitlab.com/omnibus/docker/#install-gitlab-into-a-cluster" target="_blank" rel="noopener">将GitLab安装到群集中</a></li><li><a href="https://docs.gitlab.com/omnibus/docker/#install-gitlab-using-docker-compose" target="_blank" rel="noopener">使用docker-compose安装GitLab</a></li></ul><p><strong>本文档以第一种方式在docker中运行，如你需要高可用可以用第二种，甚至是通过kubenetes deplyment部署pod方式安装。</strong></p><h4 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h4><p>需要先安装docker，请参考<a href="https://www.ipyker.com/2019/03/21/centos7-install-docker-ce/" target="_blank" rel="noopener">docker-ce安装</a></p><h4 id="运行gitlab-ce容器"><a href="#运行gitlab-ce容器" class="headerlink" title="运行gitlab-ce容器"></a>运行gitlab-ce容器</h4><pre class=" language-bash"><code class="language-bash">$ docker run -d \  --hostname gitlab.example.com \  --publish 443:443 --publish 80:80 --publish 22:22 \  --name gitlab \  --restart always \  --volume /srv/gitlab/config:/etc/gitlab \  --volume /srv/gitlab/logs:/var/log/gitlab \  --volume /srv/gitlab/data:/var/opt/gitlab \  gitlab/gitlab-ce:latest</code></pre><blockquote><p><code>docker run</code> 命令将直接拉取镜像和运行容器，相当于运行docker pull和docker start两条命令。gitlab-ce容器将制定域名，开放的端口，以及容器挂载本地的文件系统，所有GitLab数据都将存储为子目录 /srv/gitlab/。restart系统重启后，容器将自动运行。</p></blockquote><table><thead><tr><th>宿主目录</th><th>docker目录</th><th>用途</th></tr></thead><tbody><tr><td>/srv/gitlab/data</td><td>/var/opt/gitlab</td><td>用于存储应用数据</td></tr><tr><td>/srv/gitlab/logs</td><td>/var/log/gitlab</td><td>用于存储日志</td></tr><tr><td>/srv/gitlab/config</td><td>/etc/gitlab</td><td>用于存储GitLab配置文件</td></tr></tbody></table><h4 id="配置girlab-ce"><a href="#配置girlab-ce" class="headerlink" title="配置girlab-ce"></a>配置girlab-ce</h4><p>此容器使用官方的Omnibus GitLab软件包，因此所有配置都在docker唯一的配置文件中完成/etc/gitlab/gitlab.rb，也可以通过修改挂载卷文件来完成。</p><p>要访问GitLab的配置文件，您可以在正在运行的容器的上下文中启动shell会话。这将允许您浏览所有目录并使用您喜欢的文本编辑器：</p><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">exec</span> -it gitlab /bin/bash</code></pre><p>打开后，请<code>/etc/gitlab/gitlab.rb</code> 确保将指针设置<code>external_url</code> 为有效的URL。</p><p>此外您可以通过将环境变量添加<code>GITLAB_OMNIBUS_CONFIG</code> 到docker run命令来预配置GitLab Docker映像。此变量可以包含任何gitlab.rb设置，并在加载容器gitlab.rb文件之前进行评估。这样，您可以轻松配置GitLab的外部URL，从<a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/files/gitlab-config-template/gitlab.rb.template" target="_blank" rel="noopener">Omnibus GitLab</a>模板进行任何数据库配置或任何其他选项 。<br>注意：包含的设置<code>GITLAB_OMNIBUS_CONFIG</code> 不会写入gitlab.rb配置文件，而是在加载时进行评估。<br>这是一个设置外部URL并在启动容器时启用LFS的示例：</p><pre class=" language-bash"><code class="language-bash">$ docker run -d \  --hostname gitlab.example.com \  --env GITLAB_OMNIBUS_CONFIG<span class="token operator">=</span><span class="token string">"external_url 'http://my.domain.com/'; gitlab_rails['lfs_enabled'] = true;"</span> \  --publish 443:443 --publish 80:80 --publish 22:22 \  --name gitlab \  --restart always \  --volume /srv/gitlab/config:/etc/gitlab \  --volume /srv/gitlab/logs:/var/log/gitlab \  --volume /srv/gitlab/data:/var/opt/gitlab \  gitlab/gitlab-ce:latest</code></pre><p><strong>要从GitLab接收电子邮件，您必须配置 SMTP设置，因为GitLab Docker映像没有安装SMTP服务器。默认也为HTTP，还可以启动https访问。</strong></p><h4 id="重启gitlab-ce"><a href="#重启gitlab-ce" class="headerlink" title="重启gitlab-ce"></a>重启gitlab-ce</h4><p>完成所需的所有更改后，需要重新启动容器才能重新配置GitLab：</p><pre class=" language-bash"><code class="language-bash">$ docker restart gitlab</code></pre><h4 id="手动配置HTTPS"><a href="#手动配置HTTPS" class="headerlink" title="手动配置HTTPS"></a>手动配置HTTPS</h4><p>默认情况下，omnibus-gitlab不使用HTTPS。如果要为gitlab.example.com启用HTTPS，请将以下语句添加到<code>/etc/gitlab/gitlab.rb</code> ：</p><pre><code>external_url &quot;https://gitlab.example.com&quot;</code></pre><p>因为在我们的例子中，主机名是“gitlab.example.com”，所以创建<code>/etc/gitlab/ssl</code> 目录并在那里复制密钥和证书。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">mkdir</span> -p /etc/gitlab/ssl$ <span class="token function">sudo</span> <span class="token function">chmod</span> 700 /etc/gitlab/ssl$ <span class="token function">sudo</span> <span class="token function">cp</span> gitlab.example.com.key gitlab.example.com.crt /etc/gitlab/ssl/</code></pre><p>重新加载配置，当重新配置完成时，您的GitLab实例应该可以访问<a href="https://gitlab.example.com。" target="_blank" rel="noopener">https://gitlab.example.com。</a></p><pre class=" language-bash"><code class="language-bash">$ gitlab-ctl reconfigure</code></pre><blockquote><p>如果certificate.key文件有设置密码，Nginx在<code>sudo gitlab-ctl reconfigure</code> 执行时不会要求输入密码。在这种情况下，Omnibus GitLab将无声地失败，没有错误消息。要从密钥中删除密码，请使用以下命令： <code>openssl rsa -in certificate_before.key -out certificate_after.key</code> 。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CI/CD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql状态信息查询</title>
      <link href="/2018/10/22/mysql-status/"/>
      <url>/2018/10/22/mysql-status/</url>
      
        <content type="html"><![CDATA[<p>Mysql在安装运行后，其性能并不一定为实际需要的性能，因此我们常常会在mysql运行一段时间后进行mysql的性能状态查询来了解mysql服务器的性能指标，从而来优化mysql。</p><h3 id="查看mysql性能状态命令"><a href="#查看mysql性能状态命令" class="headerlink" title="查看mysql性能状态命令"></a>查看mysql性能状态命令</h3><h4 id="查看mysql全局状态"><a href="#查看mysql全局状态" class="headerlink" title="查看mysql全局状态"></a>查看mysql全局状态</h4><pre><code>mysql&gt; show global status;可以列出MySQL服务器运行各种状态值，另外，查询MySQL服务器配置信息语句。</code></pre><pre><code>mysql&gt; show variables;可以查看Mysql系统变量及其值。</code></pre><pre><code>mysql&gt; show processlist;可以查看Mysql当前连接数的进程以及状态。</code></pre><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><pre><code>mysql&gt; show variables like &#39;%slow%&#39;; +------------------+-------+ | Variable_name | Value | +------------------+-------+ | log_slow_queries | ON | | slow_launch_time | 2 | +------------------+-------+ mysql&gt; show global status like &#39;%slow%&#39;; +---------------------+-------+ | Variable_name | Value | +---------------------+-------+ | Slow_launch_threads | 0 | | Slow_queries | 4148 | +---------------------+-------+　　</code></pre><p>配置中打开了记录慢查询，执行时间超过2秒的即为慢查询，系统显示有4148个慢查询，你可以分析慢查询日志，找出有问题的SQL语句，慢查询时间不宜设置过长，否则意义不大，最好在5秒以内，如果你需要微秒级别的慢查询，可以考虑给<a href="http://www.percona.com/docs/wiki/release:start" target="_blank" rel="noopener">MySQL打补丁</a> ，记得找对应的版本。</p><p>打开慢查询日志可能会对系统性能有一点点影响，如果你的MySQL是主-从结构，可以考虑打开其中一台从服务器的慢查询日志，这样既可以监控慢查询，对系统性能影响又小。</p><h4 id="连接数"><a href="#连接数" class="headerlink" title="连接数"></a>连接数</h4><p>经常会遇见<code>”MySQL: ERROR 1040: Too many connections”</code>的情况，一种是访问量确实很高，MySQL服务器抗不住，这个时候就要考虑增加从服务器分散读压力，另外一种情况是MySQL配置文件中max_connections值过小：</p><pre><code>mysql&gt; show variables like &#39;max_connections&#39;; +-----------------+-------+ | Variable_name | Value | +-----------------+-------+ | max_connections | 256 | +-----------------+-------+　</code></pre><p>这台MySQL服务器最大连接数是256，然后查询一下服务器响应的最大连接数：</p><pre><code>mysql&gt; show global status like ‘Max_used_connections’;</code></pre><p>MySQL服务器过去的最大连接数是245，没有达到服务器连接数上限256，应该没有出现1040错误，比较理想的设置是：<code>Max_used_connections / max_connections * 100% ≈ 85%</code> 最大连接数占上限连接数的85%左右，如果发现比例在10%以下，MySQL服务器连接数上限设置的过高了。</p><h4 id="Key-buffer-size"><a href="#Key-buffer-size" class="headerlink" title="Key_buffer_size"></a>Key_buffer_size</h4><p>key_buffer_size是对MyISAM表性能影响最大的一个参数，下面一台以MyISAM为主要存储引擎服务器的配置： </p><pre><code>mysql&gt; show variables like ‘key_buffer_size’; +-----------------+------------+ | Variable_name | Value | +-----------------+------------+ | key_buffer_size | 536870912 | +-----------------+------------+　　</code></pre><p>分配了512MB内存给key_buffer_size，我们再看一下key_buffer_size的使用情况： </p><pre><code>mysql&gt; show global status like &#39;key_read%&#39;; +------------------------+-------------+ | Variable_name | Value | mysql +------------------------+-------------+ | Key_read_requests | 27813678764 | | Key_reads | 6798830 | +------------------------+-------------+　　</code></pre><p>一共有27813678764个索引读取请求，有6798830个请求在内存中没有找到直接从硬盘读取索引，计算索引未命中缓存的概率：<code>key_cache_miss_rate = Key_reads / Key_read_requests * 100%</code><br>比如上面的数据，key_cache_miss_rate为0.0244%，4000个索引读取请求才有一个直接读硬盘，已经很BT了,key_cache_miss_rate在0.1%以下都很好(每1000个请求有一个直接读硬盘)，如果key_cache_miss_rate在0.01%以下的话，key_buffer_size分配的过多，可以适当减少。<br>MySQL服务器还提供了key_blocks_*参数： </p><pre><code>mysql&gt; show global status like &#39;key_blocks_u%&#39;; +------------------------+-------------+ | Variable_name | Value | +------------------------+-------------+ | Key_blocks_unused | 0 | | Key_blocks_used | 413543 | +------------------------+-------------+　　</code></pre><p>Key_blocks_unused表示未使用的缓存簇(blocks)数，Key_blocks_used表示曾经用到的最大的blocks数，比如这台服务器，所有的缓存都用到了，要么增加key_buffer_size，要么就是过渡索引了，把缓存占满了。比较理想的设置：<br>Key_blocks_used / (Key_blocks_unused + Key_blocks_used) * 100% ≈ 80%</p><h4 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h4><pre><code>mysql&gt; show global status like &#39;created_tmp%&#39;; +-------------------------+---------+ | Variable_name | Value | +-------------------------+---------+ | Created_tmp_disk_tables | 21197 | | Created_tmp_files | 58 | | Created_tmp_tables | 1771587 | +-------------------------+---------+　　</code></pre><p>每次创建临时表，Created_tmp_tables增加，如果是在磁盘上创建临时表，Created_tmp_disk_tables也增加,Created_tmp_files表示MySQL服务创建的临时文件文件数，比较理想的配置是：<br><code>Created_tmp_disk_tables / Created_tmp_tables * 100% &lt;= 25%</code><br>比如上面的服务器<code>Created_tmp_disk_tables / Created_tmp_tables * 100% = 1.20%</code>, 应该相当好了。我们再看一下MySQL服务器对临时表的配置： </p><pre><code>mysql&gt; show variables where Variable_name in (&#39;tmp_table_size&#39;, &#39;max_heap_table_size&#39;); +---------------------+-----------+ | Variable_name | Value | +---------------------+-----------+ | max_heap_table_size | 268435456 | | tmp_table_size | 536870912 | +---------------------+-----------+　　</code></pre><p>只有256MB以下的临时表才能全部放内存，超过的就会用到硬盘临时表。</p><h4 id="Open-Table"><a href="#Open-Table" class="headerlink" title="Open Table"></a>Open Table</h4><pre><code>mysql&gt; show global status like &#39;open%tables%&#39;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | Open_tables | 919 | | Opened_tables | 1951 | +---------------+-------+　　</code></pre><p>Open_tables表示打开表的数量，Opened_tables表示打开过的表数量，如果Opened_tables数量过大，说明配置中table_cache(5.1.3之后这个值叫做table_open_cache)值可能太小，我们查询一下服务器table_cache值： </p><pre><code>mysql&gt; show variables like &#39;table_cache&#39;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | table_cache | 2048 | +---------------+-------+</code></pre><p>比较合适的值为：<br><code>Open_tables / Opened_tables * 100% &gt;= 85%</code>, 及<code>Open_tables / table_cache * 100% &lt;= 95%`</code></p><p>六、进程使用情况</p><pre><code>mysql&gt; show global status like ‘Thread%’; +-------------------+-------+ | Variable_name | Value | +-------------------+-------+ | Threads_cached | 46 | | Threads_connected | 2 | | Threads_created | 570 | | Threads_running | 1 | +-------------------+-------+　　</code></pre><p>如果我们在MySQL服务器配置文件中设置了<code>thread_cache_size</code>， 当客户端断开之后，服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁(前提是缓存数未达上限)。Threads_created表示创建过的线程数，如果发现Threads_created值过大的话，表明MySQL服务器一直在创建线程，这也是比较耗资源，可以适当增加配置文件中thread_cache_size值，查询服务器thread_cache_size配置： </p><pre><code>mysql&gt; show variables like &#39;thread_cache_size&#39;; +-------------------+-------+ | Variable_name | Value | +-------------------+-------+ | thread_cache_size | 64 | +-------------------+-------+　　</code></pre><p>示例中的服务器还是挺健康的。</p><h4 id="查询缓存-query-cache"><a href="#查询缓存-query-cache" class="headerlink" title="查询缓存(query cache)"></a>查询缓存(query cache)</h4><pre><code>mysql&gt; show global status like &#39;qcache%&#39;; +-------------------------+-----------+ | Variable_name | Value | +-------------------------+-----------+ | Qcache_free_blocks | 22756 | | Qcache_free_memory | 76764704 | | Qcache_hits | 213028692 | | Qcache_inserts | 208894227 | | Qcache_lowmem_prunes | 4010916 | | Qcache_not_cached | 13385031 | | Qcache_queries_in_cache | 43560 | | Qcache_total_blocks | 111212 | +-------------------------+-----------+　　</code></pre><p>MySQL查询缓存变量解释：<br><code>Qcache_free_blocks</code>： 缓存中相邻内存块的个数。数目大说明可能有碎片。FLUSH QUERY CACHE会对缓存中的碎片进行整理，从而得到一个空闲块。<br><code>Qcache_free_memory</code>： 缓存中的空闲内存。<br><code>Qcache_hits</code>： 每次查询在缓存中命中时就增大<br><code>Qcache_inserts</code>： 每次插入一个查询时就增大。命中次数除以插入次数就是不中比率。<br><code>Qcache_lowmem_prunes</code>： 缓存出现内存不足并且必须要进行清理以便为更多查询提供空间的次数。这个数字最好长时间来看;如果这个数字在不断增长，就表示可能碎片非常严重，或者内存很少。(上面的 free_blocks和free_memory可以告诉您属于哪种情况)<br><code>Qcache_not_cached</code>： 不适合进行缓存的查询的数量，通常是由于这些查询不是 SELECT 语句或者用了now()之类的函数。<br><code>Qcache_queries_in_cache</code>： 当前缓存的查询(和响应)的数量。<br><code>Qcache_total_blocks</code>： 缓存中块的数量。</p><p>我们再查询一下服务器关于query_cache的配置： </p><pre><code>mysql&gt; show variables like &#39;query_cache%&#39;; +------------------------------+-----------+ | Variable_name | Value | +------------------------------+-----------+ | query_cache_limit | 2097152 | | query_cache_min_res_unit | 4096 | | query_cache_size | 203423744 | | query_cache_type | ON | | query_cache_wlock_invalidate | OFF |+——————————+———–+</code></pre><p>各字段的解释：<br><code>query_cache_limit</code>： 超过此大小的查询将不缓存<br><code>query_cache_min_res_unit</code>： 缓存块的最小大小<br><code>query_cache_size</code>： 查询缓存大小<br><code>query_cache_type</code>： 缓存类型，决定缓存什么样的查询，示例中表示不缓存 select sql_no_cache 查询<br><code>query_cache_wlock_invalidate</code>： 当有其他客户端正在对MyISAM表进行写操作时，如果查询在query cache中，是否返回cache结果还是等写操作完成再读表获取结果。<br><code>query_cache_min_res_unit</code> 的配置是一柄”双刃剑”，默认是4KB，设置值大对大数据查询有好处，但如果你的查询都是小数据查询，就容易造成内存碎片和浪费。</p><p>查询缓存碎片率 = <code>Qcache_free_blocks / Qcache_total_blocks * 100%</code><br>如果查询缓存碎片率超过20%，可以用FLUSH QUERY CACHE整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。<br>查询缓存利用率 = <code>(query_cache_size - Qcache_free_memory) / query_cache_size * 100%</code><br>查询缓存利用率在25%以下的话说明<code>query_cache_size</code>设置的过大，可适当减小;查询缓存利用率在80%以上而且Qcache_lowmem_prunes &gt; 50的话说明query_cache_size可能有点小，要不就是碎片太多。<br>查询缓存命中率 = <code>(Qcache_hits - Qcache_inserts) / Qcache_hits * 100%</code><br>示例服务器 查询缓存碎片率 = 20.46%，查询缓存利用率 = 62.26%，查询缓存命中率 = 1.94%，命中率很差，可能写操作比较频繁吧，而且可能有些碎片。</p><h4 id="排序使用情况"><a href="#排序使用情况" class="headerlink" title="排序使用情况"></a>排序使用情况</h4><pre><code>mysql&gt; show global status like &#39;sort%&#39;; +-------------------+------------+ | Variable_name | Value | +-------------------+------------+ | Sort_merge_passes | 29 | | Sort_range | 37432840 | | Sort_rows | 9178691532 | | Sort_scan | 1860569 | +-------------------+------------+　　</code></pre><p><code>Sort_merge_passes</code> 包括两步。MySQL 首先会尝试在内存中做排序，使用的内存大小由系统变量 Sort_buffer_size 决定，如果它的大小不够把所有的记录都读到内存中，MySQL 就会把每次在内存中排序的结果存到临时文件中，等 MySQL 找到所有记录之后，再把临时文件中的记录做一次排序。这再次排序就会增加 Sort_merge_passes。实际上，MySQL 会用另一个临时文件来存再次排序的结果，所以通常会看到 Sort_merge_passes 增加的数值是建临时文件数的两倍。因为用到了临时文件，所以速度可能会比较慢，增加 Sort_buffer_size 会减少 Sort_merge_passes 和 创建临时文件的次数。但盲目的增加 Sort_buffer_size 并不一定能提高速度。<br>另外，增加read_rnd_buffer_size(3.2.3是record_rnd_buffer_size)的值对排序的操作也有一点的好处，参见：<a href="http://www.mysqlperformanceblog.com/2007/07/24/what-exactly-is-read_rnd_buffer_size/" target="_blank" rel="noopener">http://www.mysqlperformanceblog.com/2007/07/24/what-exactly-is-read_rnd_buffer_size/</a></p><h4 id="文件打开数-open-files"><a href="#文件打开数-open-files" class="headerlink" title="文件打开数(open_files)"></a>文件打开数(open_files)</h4><pre><code>mysql&gt; show global status like &#39;open_files&#39;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | Open_files | 1410 | +---------------+-------+ mysql&gt; show variables like &#39;open_files_limit&#39;; +------------------+-------+ | Variable_name | Value | +------------------+-------+ | open_files_limit | 4590 | +------------------+-------+　　</code></pre><p>比较合适的设置：<code>Open_files / open_files_limit * 100% &lt;= 75%</code></p><h4 id="表锁情况"><a href="#表锁情况" class="headerlink" title="表锁情况"></a>表锁情况</h4><pre><code>mysql&gt; show global status like &#39;table_locks%&#39;; +-----------------------+-----------+ | Variable_name | Value | +-----------------------+-----------+ | Table_locks_immediate | 490206328 | | Table_locks_waited | 2084912 | +-----------------------+-----------+　　</code></pre><p><code>Table_locks_immediate</code> 表示立即释放表锁数，<code>Table_locks_waited</code> 表示需要等待的表锁数，如果Table_locks_immediate / Table_locks_waited &gt; 5000，最好采用InnoDB引擎，因为InnoDB是行锁而MyISAM是表锁，对于高并发写入的应用InnoDB效果会好些。示例中的服务器Table_locks_immediate / Table_locks_waited = 235，MyISAM就足够了。</p><h4 id="表扫描情况"><a href="#表扫描情况" class="headerlink" title="表扫描情况"></a>表扫描情况</h4><pre><code>mysql&gt; show global status like &#39;handler_read%&#39;; +-----------------------+-------------+ | Variable_name | Value | +-----------------------+-------------+ | Handler_read_first | 5803750 | | Handler_read_key | 6049319850 | | Handler_read_next | 94440908210 | | Handler_read_prev | 34822001724 | | Handler_read_rnd | 405482605 | | Handler_read_rnd_next | 18912877839 | +-----------------------+-------------+　　mysql&gt; show global status like &#39;com_select&#39;; +---------------+-----------+ | Variable_name | Value | +---------------+-----------+ | Com_select | 222693559 | +---------------+-----------+　　</code></pre><p>计算表扫描率：<br>表扫描率 = Handler_read_rnd_next / Com_select<br>如果表扫描率超过4000，说明进行了太多表扫描，很有可能索引没有建好，增加read_buffer_size值会有一些好处，但最好不要超过8MB。</p><h3 id="查看Mysql状态QPS-TPS-缓存命中率"><a href="#查看Mysql状态QPS-TPS-缓存命中率" class="headerlink" title="查看Mysql状态QPS/TPS/缓存命中率"></a>查看Mysql状态QPS/TPS/缓存命中率</h3><h4 id="QPS-每秒Query量"><a href="#QPS-每秒Query量" class="headerlink" title="QPS(每秒Query量)"></a>QPS(每秒Query量)</h4><pre><code>QPS = Questions(or Queries) / seconds mysql &gt; show  global  status like &#39;Question%&#39;; </code></pre><h4 id="TPS-每秒事务量"><a href="#TPS-每秒事务量" class="headerlink" title="TPS(每秒事务量)"></a>TPS(每秒事务量)</h4><pre><code>TPS = (Com_commit + Com_rollback) / seconds mysql &gt; show global status like &#39;Com_commit&#39;; mysql &gt; show global status like &#39;Com_rollback&#39;; </code></pre><h4 id="key-Buffer-命中率"><a href="#key-Buffer-命中率" class="headerlink" title="key Buffer 命中率"></a>key Buffer 命中率</h4><pre><code>mysql&gt;show  global   status  like   &#39;key%&#39;; key_buffer_read_hits = (1-key_reads / key_read_requests) * 100% key_buffer_write_hits = (1-key_writes / key_write_requests) * 100% </code></pre><h4 id="InnoDB-Buffer命中率"><a href="#InnoDB-Buffer命中率" class="headerlink" title="InnoDB Buffer命中率"></a>InnoDB Buffer命中率</h4><pre><code>mysql&gt; show status like &#39;innodb_buffer_pool_read%&#39;; innodb_buffer_read_hits = (1 - innodb_buffer_pool_reads / innodb_buffer_pool_read_requests) * 100% </code></pre><h4 id="Query-Cache命中率"><a href="#Query-Cache命中率" class="headerlink" title="Query Cache命中率"></a>Query Cache命中率</h4><pre class=" language-`"><code class="language-`">mysql> show status like 'Qcache%'; Query_cache_hits = (Qcahce_hits / (Qcache_hits + Qcache_inserts )) * 100%; </code></pre><h4 id="Table-Cache状态量"><a href="#Table-Cache状态量" class="headerlink" title="Table Cache状态量"></a>Table Cache状态量</h4><pre><code>mysql&gt; show global  status like &#39;open%&#39;; </code></pre><p>比较 open_tables  与 opend_tables 值 </p><h4 id="Thread-Cache-命中率"><a href="#Thread-Cache-命中率" class="headerlink" title="Thread Cache 命中率"></a>Thread Cache 命中率</h4><pre><code>mysql&gt; show global status like &#39;Thread%&#39;; mysql&gt; show global status like &#39;Connections&#39;; Thread_cache_hits = (1 - Threads_created / connections ) * 100% </code></pre><h4 id="锁定状态"><a href="#锁定状态" class="headerlink" title="锁定状态"></a>锁定状态</h4><pre><code>mysql&gt; show global  status like &#39;%lock%&#39;; Table_locks_waited/Table_locks_immediate=0.3%  如果这个比值比较大的话，说明表锁造成的阻塞比较严重 Innodb_row_lock_waits innodb行锁，太大可能是间隙锁造成的 </code></pre><h4 id="复制延时量"><a href="#复制延时量" class="headerlink" title="复制延时量"></a>复制延时量</h4><pre><code>mysql &gt; show slave status 查看延时时间 </code></pre><h4 id="Tmp-Table-状况-临时表状况"><a href="#Tmp-Table-状况-临时表状况" class="headerlink" title="Tmp Table 状况(临时表状况)"></a>Tmp Table 状况(临时表状况)</h4><pre><code>mysql &gt; show status like &#39;Create_tmp%&#39;; Created_tmp_disk_tables/Created_tmp_tables比值最好不要超过10%，如果Created_tmp_tables值比较大， 可能是排序句子过多或者是连接句子不够优化 </code></pre><h4 id="Binlog-Cache-使用状况"><a href="#Binlog-Cache-使用状况" class="headerlink" title="Binlog Cache 使用状况"></a>Binlog Cache 使用状况</h4><pre><code>mysql &gt; show status like &#39;Binlog_cache%&#39;; 如果Binlog_cache_disk_use值不为0 ，可能需要调大 binlog_cache_size大小 </code></pre><h4 id="Innodb-log-waits-量"><a href="#Innodb-log-waits-量" class="headerlink" title="Innodb_log_waits 量"></a>Innodb_log_waits 量</h4><pre><code>mysql &gt; show status like &#39;innodb_log_waits&#39;; Innodb_log_waits值不等于0的话，表明 innodb log  buffer 因为空间不足而等待 </code></pre><h3 id="Mysql查看死锁和解除锁"><a href="#Mysql查看死锁和解除锁" class="headerlink" title="Mysql查看死锁和解除锁"></a>Mysql查看死锁和解除锁</h3><p>所谓死锁<deadlock>：是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用，它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。</deadlock></p><p>解除正在死锁的状态有两种方法：</p><ul><li><strong>第一种</strong><br>1.查询是否锁表<pre><code>mysql&gt; show OPEN TABLES where In_use &gt; 0;</code></pre>2.查询进程（如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程）<pre><code>mysql&gt; show processlist;</code></pre>3.杀死进程id（就是上面命令的id列）<pre><code>mysql&gt; kill id</code></pre></li><li><strong>第二种</strong><br>1.查看下在锁的事务 <pre><code>mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;</code></pre>2.杀死进程id（就是上面命令的trx_mysql_thread_id列）<pre><code>mysql&gt; kill 线程ID</code></pre></li></ul><blockquote><p>例子：<br>查出死锁进程：mysql&gt; SHOW PROCESSLIST<br>杀掉进程: mysql&gt; KILL 420821;</p></blockquote><p>其它关于查看死锁的命令：</p><pre><code>1：查看当前的事务mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;2：查看当前锁定的事务mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;3：查看当前等锁的事务mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</code></pre><p>后记：<br>文中提到一些数字都是参考值，了解基本原理就可以，除了MySQL提供的各种status值外，操作系统的一些性能指标也很重要，比如常用的top,iostat等，尤其是iostat，现在的系统瓶颈一般都在磁盘IO上，关于iostat的使用.<br>在尝试学习新的语言之前先理解这门语言的设计原理能够让你在探索这门新语言时保持一个清醒而且开发的状态。</p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zabbix服务器监控之《配置Zabbix报警》（六）</title>
      <link href="/2018/09/13/zabbox-alert/"/>
      <url>/2018/09/13/zabbox-alert/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.ipyker.com/2018/09/13/zabbix-trigger/" target="_blank" rel="noopener">上一篇</a> 我们已经配置过zabbix的触发器了，也知道当触发器阀值达到时，应该有一个动作，而这个动作可以是执行脚本，也可以是发邮件报警通知用户。那么本篇我们将再进行对zabbix的报警进行配置。</p><h2 id="报警媒介类型"><a href="#报警媒介类型" class="headerlink" title="报警媒介类型"></a>报警媒介类型</h2><p>当zabbix中的某些被监控指标出现异常时，zabbix会通过哪种方式通知运维人员呢？是通过邮件呢，还是通过短信呢，或者是通过其他方式呢？今天我们就来聊聊zabbix的报警方式，无论是通过邮件报警还是通过短信报警，无非都是通过某种”媒介”将报警信息传递给收信人，所以在zabbix中，报警方式被称为”报警媒介”，那么，zabbix都支持哪些报警媒介呢，我们一起来看看。<br>zabbix支持的报警媒介如下：</p><ul><li><code>Email</code>：邮件，这是最常用也是最传统的一种报警媒介，邮件报警，zabbix通过配置好的SMTP邮件服务器向用户发送对应的报警信息。</li><li><code>Script</code>：脚本，当zabbix中的某些监控项出现异常时，也可以调用自定义的脚本进行报警，脚本的使用就比较灵活，具体怎样报警全看你的脚本怎么写。</li><li><code>SMS</code>：短信，如果想要使用短信报警，则需要依赖短信网关（貌似需要北美的运行商）。</li><li><code>Jabber</code>：即时通讯服务。</li><li><code>Ez Texting</code>：商业的，收费的短信服务（北美运营商提供服务）。</li><li><code>第三方的onealert</code></li></ul><h2 id="定义报警媒介"><a href="#定义报警媒介" class="headerlink" title="定义报警媒介"></a>定义报警媒介</h2><blockquote><p><em>下面我们通过配置邮件报警媒介来进行配置说明</em></p></blockquote><p>点击<code>管理-报警媒介类型-创建媒介类型</code>，输入完信息后，点击<code>添加</code><br><img src="/images/pic/zabbix/zabbix-config034.png" alt><br>之后，我们可以在报警媒介类型中看到已经添加的报警类型，点击右边的<code>测试</code>，可以测试当前邮件配置是否正常，如果配置正常你将收到测试的邮件。<br><img src="/images/pic/zabbix/zabbix-config035.png" alt><br>到此处，我们已经成功的定义了一个”报警媒介”，从此，我们可以通过这个媒介，向用户发送报警信息了。</p><h2 id="配置用户接受报警通知媒介"><a href="#配置用户接受报警通知媒介" class="headerlink" title="配置用户接受报警通知媒介"></a>配置用户接受报警通知媒介</h2><p>但是，如果想要某个zabbix用户能够接收到从”email报警媒介”发送过来的报警，还需要进一步配置，比如，当”Admin”用户想要通过”email”报警媒介接收警报时，则必须能够”适配”这种媒介，如果”Admin”用户没有使用”email媒介”的能力，那么”Admin”用户将无法接收到由”email媒介”发出的报警信息。我们应该怎样让用户能够对应的报警媒介呢，配置步骤如下。</p><p>点击<code>管理-用户-Admin-报警媒介</code><br><img src="/images/pic/zabbix/zabbix-config036.png" alt><br>到此处，我们已经成功的定义了一个用户能接受对应”报警媒介”的邮件通知了。</p><h2 id="配置告警动作"><a href="#配置告警动作" class="headerlink" title="配置告警动作"></a>配置告警动作</h2><blockquote><p>在zabbix中创建一个动作，前文中我们已经创建了用于监控磁盘根目录使用率的监控项,以及对应的触发器，现在，我们需要创建一个动作，与监控项和触发器结合起来一起使用。 </p></blockquote><p>打开zabbix控制台，点击<code>配置-动作-事件源-触发器-创建动作</code><br><img src="/images/pic/zabbix/zabbix-config037.png" alt><br>点击<code>操作</code><br><img src="/images/pic/zabbix/zabbix-config038.png" alt><br>点击<code>恢复操作</code><br><img src="/images/pic/zabbix/zabbix-config039.png" alt><br>完成以上配置，点击<code>添加</code>即可添加一个对该触发器的动作。 </p><p><strong>上图报警的宏如下，更多的宏参考<a href="https://www.zabbix.com/documentation/4.0/zh/manual/appendix/macros/supported_by_location" target="_blank" rel="noopener">官方宏使用</a> </strong></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 故障时</span>默认标题：故障<span class="token punctuation">{</span>TRIGGER.STATUS<span class="token punctuation">}</span>,服务器:<span class="token punctuation">{</span>HOSTNAME<span class="token punctuation">}</span>发生: <span class="token punctuation">{</span>TRIGGER.NAME<span class="token punctuation">}</span>故障<span class="token operator">!</span>消息内容：告警主机:<span class="token punctuation">{</span>HOSTNAME<span class="token punctuation">}</span>告警时间:<span class="token punctuation">{</span>EVENT.DATE<span class="token punctuation">}</span> <span class="token punctuation">{</span>EVENT.TIME<span class="token punctuation">}</span>告警等级:<span class="token punctuation">{</span>TRIGGER.SEVERITY<span class="token punctuation">}</span>告警信息: <span class="token punctuation">{</span>TRIGGER.NAME<span class="token punctuation">}</span>告警项目:<span class="token punctuation">{</span>TRIGGER.KEY<span class="token punctuation">}</span>问题详情:<span class="token punctuation">{</span>ITEM.NAME<span class="token punctuation">}</span>:<span class="token punctuation">{</span>ITEM.VALUE<span class="token punctuation">}</span>当前状态:<span class="token punctuation">{</span>TRIGGER.STATUS<span class="token punctuation">}</span>:<span class="token punctuation">{</span>ITEM.VALUE<span class="token punctuation">}</span>事件ID:<span class="token punctuation">{</span>EVENT.ID<span class="token punctuation">}</span>恢复时默认标题：恢复<span class="token punctuation">{</span>TRIGGER.STATUS<span class="token punctuation">}</span>, 服务器:<span class="token punctuation">{</span>HOSTNAME<span class="token punctuation">}</span>: <span class="token punctuation">{</span>TRIGGER.NAME<span class="token punctuation">}</span>已恢复<span class="token operator">!</span>消息内容：告警主机:<span class="token punctuation">{</span>HOSTNAME<span class="token punctuation">}</span>告警时间:<span class="token punctuation">{</span>EVENT.DATE<span class="token punctuation">}</span> <span class="token punctuation">{</span>EVENT.TIME<span class="token punctuation">}</span>告警等级:<span class="token punctuation">{</span>TRIGGER.SEVERITY<span class="token punctuation">}</span>告警信息: <span class="token punctuation">{</span>TRIGGER.NAME<span class="token punctuation">}</span>告警项目:<span class="token punctuation">{</span>TRIGGER.KEY<span class="token punctuation">}</span>问题详情:<span class="token punctuation">{</span>ITEM.NAME<span class="token punctuation">}</span>:<span class="token punctuation">{</span>ITEM.VALUE<span class="token punctuation">}</span>当前状态:<span class="token punctuation">{</span>TRIGGER.STATUS<span class="token punctuation">}</span>:<span class="token punctuation">{</span>ITEM.VALUE<span class="token punctuation">}</span>事件ID:<span class="token punctuation">{</span>EVENT.ID<span class="token punctuation">}</span></code></pre><h2 id="模拟告警"><a href="#模拟告警" class="headerlink" title="模拟告警"></a>模拟告警</h2><p>在此之前我们已经总结了主机、监控项、触发器、事件、动作等相关知识点，但是到目前为止，还没有真正的收到过任何一个zabbix中的警告，那么这次，我们就在之前的基础上，刻意的让磁盘根目录使用率这个监控项达到指定的阈值，看看能否正常的收到报警信息。<br><img src="/images/pic/zabbix/zabbix-config040.png" alt><br>在模拟前，我们先看看之前磁盘根目录使用率是多少，使用率0.39% 阀值5%。好了，现在我们进入到被监控主机的根分区，在根分区中创建一个大文件，提高磁盘使用率。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s nginx<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># dd if=/dev/zero of=/testfile count=20 bs=1G</span>记录了20+0 的读入记录了20+0 的写出21474836480字节<span class="token punctuation">(</span>21 GB<span class="token punctuation">)</span>已复制，44.8811 秒，478 MB/秒<span class="token punctuation">[</span>root@k8s nginx<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># df -h</span>文件系统        容量  已用  可用 已用% 挂载点/dev/sda5       296G   22G  275G    8% /devtmpfs        3.9G     0  3.9G    0% /devtmpfs           3.9G     0  3.9G    0% /dev/shmtmpfs           3.9G   18M  3.9G    1% /runtmpfs           3.9G     0  3.9G    0% /sys/fs/cgroup/dev/sda2       200G   33M  200G    1% /home/dev/sda1       297M  107M  191M   36% /boottmpfs           797M     0  797M    0% /run/user/0</code></pre><p>此时我们的根分区使用率已经达到了8%，超过了触发器设置的阀值5%，我们看看下图，（这里显示的是7.16%和df -h命令8%差一点点是由于linux只显示整数，小数点增1位）<br><img src="/images/pic/zabbix/zabbix-config041.png" alt><br>我们配置的是1分钟检测一次，因此我们能很快收到<code>故障邮件通知</code>报警。如下<br><img src="/images/pic/zabbix/zabbix-config042.png" alt><br>此时我们删掉<code>dd命令</code>生成的testfile文件进行恢复测试。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s /<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rm -rf testfile </span><span class="token punctuation">[</span>root@k8s /<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># df -h</span>文件系统        容量  已用  可用 已用% 挂载点/dev/sda5       296G  1.2G  295G    1% /devtmpfs        3.9G     0  3.9G    0% /devtmpfs           3.9G     0  3.9G    0% /dev/shmtmpfs           3.9G   18M  3.9G    1% /runtmpfs           3.9G     0  3.9G    0% /sys/fs/cgroup/dev/sda2       200G   33M  200G    1% /home/dev/sda1       297M  107M  191M   36% /boottmpfs           797M     0  797M    0% /run/user/0</code></pre><p>那么很快我们将收到监控项<code>恢复的邮件通知</code><br><img src="/images/pic/zabbix/zabbix-config043.png" alt><br>至此，我们已经完成了初步的zabbix使用了。也可以用户监控环境去监控服务了，当然监控项、触发器等还需要根据实际情况去配置。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zabbix服务器监控之《配置Zabbix触发器》（五）</title>
      <link href="/2018/09/13/zabbix-trigger/"/>
      <url>/2018/09/13/zabbix-trigger/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.ipyker.com/2018/09/12/zabbix-item/" target="_blank" rel="noopener">上一篇</a> 我们已经配置过zabbix的监控项了，本篇我们将再进行对监控项的触发器配置。而在配置zabbix触发器前，我们再来理解一下<code>触发器</code>，<code>事件</code>，<code>动作</code>。</p><p><code>触发器（Triggers）</code>：我们可以把zabbix的触发器理解成一个条件表达式，我们往往通过触发器定义被监控项的阈值，当触发器对应的表达式被满足时，则代表被监控项达到了我们设定的阈值，也就意味着发生了我们不想要遇到的问题，换句话说，当监控项的值处于合理范围时，触发器不会被触发，当监控项的值超出合理范围（即达到阈值），触发器则会被触发，当触发器被触发时，往往代表着出现了问题，触发器未被触发时，其的状态为”OK”,当触发器被触发时，触发器的状态为”Problem”，当被监控项的值达到阈值时，触发器的状态从”OK”变为”Problem”,当监控项的值再次回归到合理范围时，触发器的状态会从”Problem”转换回”OK”。</p><p><code>事件（Events）</code>：当触发器的状态发生改变时，则会产生对应的”事件”，当然，由触发器的状态改变而产生的事件被称为”触发器事件”，zabbix中，事件分为几种类型，除了”触发器事件”，还有一些别的事件，此处为了方便描述，暂且不提及他们，我们可以把”事件”大概理解成一个重要的事情。</p><p><code>动作（Actions）</code>：当某个事件产生时，需要对应的处理措施，这种处理措施被称为动作。</p><h2 id="配置触发器"><a href="#配置触发器" class="headerlink" title="配置触发器"></a>配置触发器</h2><blockquote><p><em>我们还是以上节监控nginx1主机根目录的监控项为例进行创建触发器</em></p></blockquote><p>点击<code>配置-主机</code>进入对应主机上的<code>触发器</code>后，点击右上角的<code>创建触发器</code><br><img src="/images/pic/zabbix/zabbix-config029.png" alt><br>根据下图配置触发器信息，触发器也可以在模版的监控项中创建，也可以在主机中创建。<br><img src="/images/pic/zabbix/zabbix-config030.png" alt><br>点击<code>添加</code>后，我们可以在对应主机中查看根目录使用率的触发器<br><img src="/images/pic/zabbix/zabbix-config031.png" alt><br>最后，我们在<code>监测-最新数据</code>中过滤显示根目录使用率监控项，点击图形，可以看到该监控项已经有触发器了。<br><img src="/images/pic/zabbix/zabbix-config032.png" alt><br>至此，一个关于磁盘根目录使用率超过5%后的触发器就配置完成。然而当这个监控项的值达到我们指定的阈值5%时，就会产生某个”事件”，以便我们采取后续的措施，而这个后续操作可以是命令，也可以是报警通知。</p><h2 id="触发器表达式说明"><a href="#触发器表达式说明" class="headerlink" title="触发器表达式说明"></a>触发器表达式说明</h2><p>如下图，触发器的表达式生成方式<br><img src="/images/pic/zabbix/zabbix-config033.png" alt></p><blockquote><p>其实，上面的5个部分我们可以通过如下语法表示，如下语法描述了一个触发器的条件表达式的基本结构，<code>{&lt;server&gt;:&lt;key&gt;.&lt;function&gt;(&lt;parameter&gt;)}&lt;operator&gt;&lt;constant&gt;</code></p></blockquote><p>下面我们对触发器的表达式语法进行说明，如：<code>{web server1:vfs.fs.size[/,pused].last()}&gt;5</code>，那么，我们把该表达式分解成5个部分，从而方便我们去理解。</p><ul><li><code>web server1</code>：表示主机名称。</li><li><code>vfs.fs.size[/,pused]</code>：表示对应主机上某个监控项对应的key。</li><li><code>last()</code>：对应上述语法中的<function>(<parameter>)，last()被我们称之为函数。</parameter></function></li><li><code>\&gt;</code>：对应了上述语法中的<operator>，其实就是常用的比较操作符或者运算操作符。</operator></li><li><code>5</code>：表示用于设定监控项对应的阈值。</li></ul><p><code>function</code>除了last()常用的有 avg、count、change、sum、max、min、date等，看这些函数的名字你也能猜出其大概的作用，无非就是获取监控项的值的最大值，最小值，值的总和，或者平均值等，如果你想要了解它们，可以登录zabbix的官网查看<a href="https://www.zabbix.com/documentation/4.0/zh/manual/appendix/triggers/functions" target="_blank" rel="noopener">触发器表达式函数在线手册</a></p><p>而函数的参数格式变化则比较少，如果参数值前面带有”#”作为前缀,则表示次数，比如avg(#10),则表示最近10次监控项的值的平均值，如果参数值前面没有”#”作为前缀，则表示时间，比如sum(300),表示300秒内监控项的值的总和，max(#20)则表示最近20次监控项的值的最大值，min(600)则表示最近10分钟内监控项的值的最小值，但是需要注意，last(0)的含义与last(#1)的含义相同，都表示最近一次。有的函数还支持使用第二个参数，比如avg(1h,1d) ，表示一天前的一小时内的监控项的值的平均值，假设现在的时间是5点，avg(1h)可以理解为4点到5点之间的监控项的值的平均值，而avg(1h,1d) 中的1d表示时间偏移量，那么avg(1h,1d)可以理解为昨天4点到5点的监控项的值的平均值。</p><p><code>operator</code>，其实就是常用的比较操作符或者运算操作符，由于zabbix版本的不同，操作符可能有所变化，zabbix4.0支持的操作符可以<a href="https://www.zabbix.com/documentation/4.0/zh/manual/config/triggers/expression" target="_blank" rel="noopener">操作符参考在线手册</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zabbix服务器监控之《配置Zabbix监控项》（四）</title>
      <link href="/2018/09/12/zabbix-item/"/>
      <url>/2018/09/12/zabbix-item/</url>
      
        <content type="html"><![CDATA[<p>通过<a href="https://www.ipyker.com/2018/09/11/zabbix-agent/" target="_blank" rel="noopener">上一篇</a> 我们已经进行了对zabbix的agent端安装，以及通过手动、自动发现、自动注册的方式将agent端监控到server端，也知道<code>应用集</code>、<code>监控项</code>、<code>触发器</code>是什么概念。那么本篇我们将实际配置zabbix的监控项。</p><h2 id="监控项说明"><a href="#监控项说明" class="headerlink" title="监控项说明"></a>监控项说明</h2><p>在Zabbix中，我们要监控的某一个指标，被称为“监控项(item)”，比如监控磁盘的使用率，这就属于一个监控项，如果要获取到”监控项”的相关信息，我们则要执行一个命令，但是我们不能直接调用命令，而是通过一个”别名”去调用命令，这个”命令别名”在zabbix中被称为”键”(key)，所以，在zabbix中，如果我们想要获取到一个”监控项”的值，则需要有对应的”键”，通过”键”能够调用相应的命令，获取到对应的监控信息，而监控项的key、键值又可以为<code>带参数</code>和<code>不带参数</code>两种，下面我们将分别对其进行说明配置。 </p><ul><li><strong>不参数键值</strong><br>监控项键值中只有键名的键称为不带参数的键值，如<code>system.cpu.switches</code> </li><li><strong>带参数的键值</strong><br>监控项键值中有键名和参数的键值，如<code>vfs.fs.size[fs,&lt;mode&gt;]</code>，对于<code>vfs.fs.size[fs,&lt;mode&gt;]</code>这个键来说，<code>vfs.fs.size</code>就是键名，<code>[fs,&lt;mode&gt;]</code>就是这个键需要的参数。而<code>[fs,&lt;mode&gt;]</code>这两个参数中，<code>fs</code>是不可省参数，<code>mode</code>是可省参数。</li></ul><h2 id="配置监控项"><a href="#配置监控项" class="headerlink" title="配置监控项"></a>配置监控项</h2><p>监控项可以单独配置在主机中，使该监控项专属于该主机。也可以配置在相应模版中，然后主机对该模版进行链接，从而使该主机也具有该模版的所有监控项。 </p><p><font color="#FF0000">在通常配置zabbix监控时，我们通常将监控项配置在模版中，这样方便调度和管理。(以下配置也采用监控项配置在模版里)</font></p><blockquote><p>系统默认自带一些模版，这些模版有监控CPU的、内存的、http的等等，如果没有自己需要的也可以自定义模版，应用集、监控项、触发器等。</p></blockquote><h3 id="配置不带参数的监控项"><a href="#配置不带参数的监控项" class="headerlink" title="配置不带参数的监控项"></a>配置不带参数的监控项</h3><p>点击<code>配置-模版-Template OS Linux</code> 找到Template OS Linux模版<br><img src="/images/pic/zabbix/zabbix-config021.png" alt></p><p>点击Template OS Linux模版中的<code>监控项-创建监控项</code>，完成下图设置后<code>添加</code><br>现在我们想要在Template OS Linux模版中创建CPU的上下文切换的监控项，那么我们可以在此界面进行如下配置。<br><img src="/images/pic/zabbix/zabbix-config022.png" alt><br>现在我们可以看到在Template OS Linux模版中已经有我们刚刚创建的名为Context switches per second监控项<br><img src="/images/pic/zabbix/zabbix-config023.png" alt><br>此时我们让主机和该模版关联，使主机能使用该模版的监控项， 点击<code>配置-主机-模版</code>，把Template OS Linux模版链接到主机中<br><img src="/images/pic/zabbix/zabbix-config024.png" alt><br>完成以上操作后，我们对主机进行cpu上下文监控也就配置完成，可以等待2分钟让zabbix进行数据采集后，在<code>监测-最新数据</code>通过过滤器过滤出CPU上下文切换的监控项最新数据<br><img src="/images/pic/zabbix/zabbix-config025.png" alt><br>也可以点击旁边的图形，查看图形信息<br><img src="/images/pic/zabbix/zabbix-config026.png" alt></p><h3 id="配置带参数的监控项"><a href="#配置带参数的监控项" class="headerlink" title="配置带参数的监控项"></a>配置带参数的监控项</h3><p>点击Template OS Linux模版中的<code>监控项-创建监控项</code>，由于配置项已在上面说明，我们只阐述不同的地方<br><img src="/images/pic/zabbix/zabbix-config027.png" alt><br>由于Template OS Linux模版在上面已经加入到nginx1主机了，所以我们这里就不做主机和模版关联了<br><img src="/images/pic/zabbix/zabbix-config024.png" alt><br>最后等待几分钟在<code>监测-最新数据</code>通过过滤器过滤出磁盘使用率的监控项最新数据<br><img src="/images/pic/zabbix/zabbix-config028.png" alt></p><blockquote><p>关于这个键到底怎么使用呢，类似和fs和mode这两个参数分别代表了什么呢，我们可以通过<a href="https://www.zabbix.com/documentation/4.0/zh/manual/config/items/itemtypes/zabbix_agent" target="_blank" rel="noopener">官网帮助手册</a>，查看这些”键”的含义与使用方法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zabbix服务器监控之《安装Zabbix Agent》（三）</title>
      <link href="/2018/09/11/zabbix-agent/"/>
      <url>/2018/09/11/zabbix-agent/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.ipyker.com/2018/09/11/zabbix-server/" target="_blank" rel="noopener">上一篇</a> 我们已经进行了对zabbix的server端安装，本篇我们将进行对Zabbix agent端安装配置！</p><p>通过<a href="https://www.ipyker.com/2018/09/11/zabbix-summarize/" target="_blank" rel="noopener">第一篇</a> 我们已经知道<code>server-agent</code> 都是部署到被监控主机上，由agent采集数据，报告给zabbix-server端进行监控的。</p><h2 id="安装Zabbix代理端"><a href="#安装Zabbix代理端" class="headerlink" title="安装Zabbix代理端"></a>安装Zabbix代理端</h2><blockquote><p>由于zabbix-server用的是4.2版，那么我们agent也用4.2版。</p></blockquote><h3 id="yum安装zabbix-agent"><a href="#yum安装zabbix-agent" class="headerlink" title="yum安装zabbix-agent"></a>yum安装zabbix-agent</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#yum安装zabbix源</span>$ rpm -Uvh https://repo.zabbix.com/zabbix/4.2/rhel/7/x86_64/zabbix-release-4.2-1.el7.noarch.rpm<span class="token comment" spellcheck="true"># 安装zabbix-agent代理端</span><span class="token comment" spellcheck="true"># zabbix_sender` 为测试是否能够向server端发送数据的工具</span>$ yum <span class="token function">install</span> -y zabbix-agent zabbix-sender</code></pre><h3 id="zabbix代理端配置"><a href="#zabbix代理端配置" class="headerlink" title="zabbix代理端配置"></a>zabbix代理端配置</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 修改/etc/zabbix/zabbix_agentd.conf配置文件</span><span class="token comment" spellcheck="true"># 设置被动模式下zabbix-server的IP地址</span>Server<span class="token operator">=</span>192.168.20.210<span class="token comment" spellcheck="true"># 设置主动模式下zabbix-server的IP地址</span>ServerActive<span class="token operator">=</span>192.168.20.210<span class="token comment" spellcheck="true"># 设置本机zabbix-agent主机名称</span>Hostname<span class="token operator">=</span>web server1</code></pre><h3 id="启动zabbix代理端"><a href="#启动zabbix代理端" class="headerlink" title="启动zabbix代理端"></a>启动zabbix代理端</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 启动zabbix-agent</span>$ systemctl start zabbix-agent<span class="token comment" spellcheck="true"># 开机自启动zabbix-agent`</span>$ systemctl <span class="token function">enable</span> zabbix-agent</code></pre><blockquote><p>默认情况下，zabbix-agent不能使用root用户运行的，如果非要以root用户运行，可以在<code>/etc/zabbix/zabbix_agentd.conf</code> 配置文件中设置<code>AllowRoot=1</code> </p></blockquote><p><strong>此时查看zabbix-agent进程和端口是否正常：</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看端口是否正常</span>$ <span class="token function">netstat</span> -ptlnProto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    tcp        0      0 0.0.0.0:10050           0.0.0.0:*               LISTEN      11734/zabbix_agentd <span class="token comment" spellcheck="true"># 查看进程是否正常</span>$ <span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> zabbix_agentzabbix    11734      1  0 4月13 ?       00:00:00 /usr/sbin/zabbix_agentd -c /etc/zabbix/zabbix_agentd.confzabbix    11735  11734  0 4月13 ?       00:00:00 /usr/sbin/zabbix_agentd: collector <span class="token punctuation">[</span>idle 1 sec<span class="token punctuation">]</span>zabbix    11736  11734  0 4月13 ?       00:00:00 /usr/sbin/zabbix_agentd: listener <span class="token comment" spellcheck="true">#1 [waiting for connection]</span>zabbix    11737  11734  0 4月13 ?       00:00:00 /usr/sbin/zabbix_agentd: listener <span class="token comment" spellcheck="true">#2 [waiting for connection]</span>zabbix    11738  11734  0 4月13 ?       00:00:00 /usr/sbin/zabbix_agentd: listener <span class="token comment" spellcheck="true">#3 [waiting for connection]</span>zabbix    11739  11734  0 4月13 ?       00:00:00 /usr/sbin/zabbix_agentd: active checks <span class="token comment" spellcheck="true">#1 [idle 1 sec]</span>root      12105  11549  0 00:23 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto zabbix_agent</code></pre><p>至此<code>zabbix-agent</code> 代理端安装完毕。</p><h2 id="监控zabbix-agent代理端"><a href="#监控zabbix-agent代理端" class="headerlink" title="监控zabbix-agent代理端"></a>监控zabbix-agent代理端</h2><p>zabbix-server监控zabbix-agent有两种方式：</p><ul><li>手动添加对应的zabbix-agent客户端</li><li>自动发现和自动注册</li></ul><blockquote><p>手动添加zabbix-agent适用于少量的被监控主机，而自动发现主要是通过发现网络中的主机，并自动把主机添加到监控中，并关联特定的模板，实现自动监控，适合有大量被监控主机，减少频繁手动添加主机的麻烦操作。</p></blockquote><h3 id="手动添加zabbix-agent客户端"><a href="#手动添加zabbix-agent客户端" class="headerlink" title="手动添加zabbix-agent客户端"></a>手动添加zabbix-agent客户端</h3><p>浏览器输入<code>http://192.168.20.210/zabbix</code> ，访问zabbix服务，点击<code>配置-主机-创建主机</code><br><img src="/images/pic/zabbix/zabbix-config010.png" alt><br>点击<code>模版</code> ，选择主机属于哪个模版 （模版里面包含需要监控的条目）<br><img src="/images/pic/zabbix/zabbix-config011.png" alt><br>点击<code>添加</code><br><img src="/images/pic/zabbix/zabbix-config012.png" alt></p><ul><li><code>应用集</code>：  表示模版中监控业务的一类型。（如：CPU应用集属于Template OS Linx模版）</li><li><code>监控项</code>：  表示某一应用集中监控的某一项。（如：CPU负载、CPU使用率都属于CPU应用集中的监控项）</li><li><code>触发器</code>：  表示某一监控项达到某自定义的阀值时，该出现的状态。（如：当CPU使用率达到70%设置他的状态为警告，80%为严重，这就属于触发器）</li><li><code>图 形</code>：   表示哪些监控项进行了图形显示。（如：将CPU使用率用图形显示一段时间里的曲线变化）</li><li><code>自动发现</code>：表示哪些监控项是可以通过自动发现进行监控。（如：自动发现主机网络接口流量）</li><li><code>web监测</code>:  表示zabbix把web某页面也监控起来，第一时间得知web崩溃信息并做相应处理。（如：监控http某一页面，如果状态码不是200，通过触发器返回严重告警）</li></ul><p>至此手动添加zabbix-agent客户端步骤完成，可以在<code>监控-图形</code>中查看对监控项设置了图形的状态了。<br><img src="/images/pic/zabbix/zabbix-config013.png" alt></p><h3 id="自动发现"><a href="#自动发现" class="headerlink" title="自动发现"></a>自动发现</h3><p>当监控主机不断增多，有的时候需要添加一批机器，特别是刚用zabbix的运维人员需要将公司的所有服务器添加到zabbix，如果使用传统办法去单个添加设备、分组、项目、图像…..结果可想而知。鉴于这个问题我们可以好好利用下Zabbix的一个发现(Discovery)模块，进而来实现自动刚发现主机、自动将主机添加到主机组、自动加载模板、自动创建项目（item）、自动创建图像，下面我们来看看这个模块如何使用。</p><blockquote><p>自动发现由服务端主动发起，Zabbix Server开启发现进程，定时扫描局域网中IP服务器、设备。</p></blockquote><p><strong>自动发现过程需要分为两个步骤：</strong></p><ul><li>通过网络扫描制定的服务，如：Zabbix Agent是否可以访问system.uname指标</li><li>发现主机之后需要执行添加的动作，这个过程由动作（Action）完成</li></ul><p>点击<code>配置-自动发现-创建发现规则</code>填入名称、需发现服务器、设备的IP范围、更新间隔、检查项（ssh和zabbix客户端）、设备唯一性准则，最后勾选已启用、点击添加。进行自动发现规则的创建<br><img src="/images/pic/zabbix/zabbix-config014.png" alt></p><p>在点击<code>配置-动作-事件源-自动发现-创建动作</code> 进行主机自动加入主机组并关联模板<br><img src="/images/pic/zabbix/zabbix-config015.png" alt><br>点击<code>操作</code> 对该动作关联到模版的操作<br><img src="/images/pic/zabbix/zabbix-config016.png" alt><br><code>添加到主机</code>：将发现到的主机添加到主机<br><code>添加到主机群组</code>：选择要添加到的主机组<br><code>链接到模版</code>：链接到模板、选择相应的模板 </p><p>点击<code>添加</code>完成动作规则的创建，至此发现主机、添加主机并将主机添加到主机组、链接模板全部完毕。</p><p>此时可以在<code>监测-自动发现</code>中看到已经被自动发现规则监测到的内网服务器！也可以在<code>配置-主机群组-Discovered hosts</code>中看到已经被自动发现的主机。也可以在<code>监测-图形</code>中查看自动发现的主机监控项的图形。<br><img src="/images/pic/zabbix/zabbix-config017.png" alt></p><h3 id="自动注册"><a href="#自动注册" class="headerlink" title="自动注册"></a>自动注册</h3><p>当主机分布在不同的城市，比如不同的云环境中时，使用主动发现就不好处理了，使用自动注册的方式非常适合在云环境中的部署。</p><blockquote><p>由客户端主动发起，客户端必须安装并启动Agentd，否则无法被自动注册添加至主机列表。</p></blockquote><p>点击<code>配置-动作-事件源-自动注册-创建动作</code> 进行主机自动加入主机组并关联模板<br><img src="/images/pic/zabbix/zabbix-config018.png" alt><br>点击<code>操作</code>选择具体的操作类型：添加主机、添加到主机群组、与模板关联的操作，最后点击添加。</p><p><img src="/images/pic/zabbix/zabbix-config019.png" alt></p><p>在<code>配置-主机</code>中查看注册的设备信息<br><img src="/images/pic/zabbix/zabbix-config020.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zabbix服务器监控之《安装Zabbix Server》（二）</title>
      <link href="/2018/09/11/zabbix-server/"/>
      <url>/2018/09/11/zabbix-server/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.ipyker.com/2018/09/11/zabbix-summarize/" target="_blank" rel="noopener">上一篇</a> 我们已经讲了zabbix的常用组件和工作模式，本篇我们将进行对Zabbix Server端安装配置！</p><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><table><thead><tr><th>系统</th><th>版本</th><th>IP</th><th>关系</th></tr></thead><tbody><tr><td>centos</td><td>7.5</td><td>192.168.20.210</td><td>服务端</td></tr><tr><td>centos</td><td>7.5</td><td>192.168.20.211</td><td>代理端</td></tr></tbody></table><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ul><li>设置主机名，重启生效</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># server端</span>$ <span class="token keyword">echo</span> <span class="token string">"zabbix-server"</span> <span class="token operator">></span> /etc/hostname<span class="token comment" spellcheck="true"># agent端</span>$ <span class="token keyword">echo</span> <span class="token string">"zabbix-agent"</span> <span class="token operator">></span> /etc/hostname</code></pre><ul><li>关闭SELinux和防火墙检查</li></ul><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sed</span> -i <span class="token string">"s/SELINUX=enforcing/SELINUX=disabled/g"</span> /etc/selinux/config$ systemctl stop firewalld.service$ systemctl disable firewalld.service</code></pre><h2 id="安装Zabbix服务端"><a href="#安装Zabbix服务端" class="headerlink" title="安装Zabbix服务端"></a>安装Zabbix服务端</h2><blockquote><p>我们这里安装的zabbix版本为4.2版本</p></blockquote><h3 id="yum安装zabbix-server"><a href="#yum安装zabbix-server" class="headerlink" title="yum安装zabbix-server"></a>yum安装zabbix-server</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#yum安装zabbix源</span>$ rpm -Uvh https://repo.zabbix.com/zabbix/4.2/rhel/7/x86_64/zabbix-release-4.2-1.el7.noarch.rpm<span class="token comment" spellcheck="true">#安装zabbix服务端</span><span class="token comment" spellcheck="true">#zabbix-get为测试是否能够从agent端拉取数据的工具</span>$ yum -y <span class="token function">install</span> zabbix-server-mysql zabbix-web-mysql zabbix-agent zabbix-get</code></pre><h3 id="安装mysql数据库"><a href="#安装mysql数据库" class="headerlink" title="安装mysql数据库"></a>安装mysql数据库</h3><blockquote><p>如果有现有的数据库环境，请跳过安装数据库环节，直接从<code>创建zabbix数据库</code> 开始。</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在线yum安装mysql5.7</span>$ <span class="token function">wget</span> -c https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm$ rpm -ivh mysql80-community-release-el7-1.noarch.rpm$ yum -y <span class="token function">install</span> yum-utils$ yum-config-manager --disable mysql80-community$ yum-config-manager --enable mysql57-community$ yum <span class="token function">install</span> mysql-community-server -y<span class="token comment" spellcheck="true"># 启动mysql</span>$ systemctl start mysqld<span class="token comment" spellcheck="true"># 开机启动</span>$ systemctl <span class="token function">enable</span> mysqld</code></pre><p>修改root密码</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看mysql临时密码</span>$ <span class="token function">grep</span> <span class="token string">'temporary password'</span> /var/log/mysqld.log<span class="token comment" spellcheck="true"># 使用mysql临时登录，修改root密码</span>mysql<span class="token operator">></span> ALTER USER <span class="token string">'root'</span>@<span class="token string">'localhost'</span> IDENTIFIED BY <span class="token string">'Ala@2018'</span><span class="token punctuation">;</span></code></pre><h3 id="创建zabbix数据库"><a href="#创建zabbix数据库" class="headerlink" title="创建zabbix数据库"></a>创建zabbix数据库</h3><p>创建zabbix用户和库</p><pre class=" language-bash"><code class="language-bash">mysql<span class="token operator">></span> create database zabbix character <span class="token keyword">set</span> utf8 collate utf8_bin<span class="token punctuation">;</span>mysql<span class="token operator">></span> grant all privileges on zabbix.* to zabbix@localhost identified by <span class="token string">"Ala@2018"</span><span class="token punctuation">;</span></code></pre><h3 id="导入zabbix数据库"><a href="#导入zabbix数据库" class="headerlink" title="导入zabbix数据库"></a>导入zabbix数据库</h3><p>在shell命令行执行导入zabbix数据</p><pre class=" language-bash"><code class="language-bash">$ zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz <span class="token operator">|</span> mysql -uzabbix -p<span class="token string">'Ala@2018'</span> zabbix</code></pre><h3 id="zabbix服务端配置"><a href="#zabbix服务端配置" class="headerlink" title="zabbix服务端配置"></a>zabbix服务端配置</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 配置zabbix连接的数据库地址、数据库名以及数据库用户</span>DBHost<span class="token operator">=</span>localhostDBName<span class="token operator">=</span>zabbixDBUser<span class="token operator">=</span>zabbix<span class="token comment" spellcheck="true"># 修改`/etc/zabbix/zabbix_server.conf` 文件，修改mysql连接密码</span>DBPassword<span class="token operator">=</span>Ala@2018<span class="token comment" spellcheck="true"># 添加上海区</span>$ <span class="token function">sed</span> -i.ori <span class="token string">'19a php_value date.timezone  Asia/Shanghai'</span> /etc/httpd/conf.d/zabbix.conf<span class="token comment" spellcheck="true"># 解决图形列表下中文乱码</span>$ yum -y <span class="token function">install</span> wqy-microhei-fonts$ <span class="token function">mv</span> /usr/share/fonts/dejavu/DejaVuSans.ttf /usr/share/fonts/dejavu/DejaVuSans.ttf.bak$ <span class="token function">cp</span> -f /usr/share/fonts/wqy-microhei/wqy-microhei.ttc /usr/share/fonts/dejavu/DejaVuSans.ttf</code></pre><h3 id="启动zabbix服务端并配置"><a href="#启动zabbix服务端并配置" class="headerlink" title="启动zabbix服务端并配置"></a>启动zabbix服务端并配置</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 启动 zabbix-server和httpd服务</span>$ systemctl start zabbix-server httpd<span class="token comment" spellcheck="true"># 开机启动</span>$ systemctl <span class="token function">enable</span> zabbix-server httpd</code></pre><p>浏览器输入<code>http://192.168.20.210/zabbix</code> ，访问zabbix，如下图<br><img src="/images/pic/zabbix/zabbix-config001.png" alt><br>接下来点击 Next setup<br><img src="/images/pic/zabbix/zabbix-config002.png" alt><br>从上图可以看到zabbix相关组件配置，继续点击 Next setup<br><img src="/images/pic/zabbix/zabbix-config003.png" alt><br>上图中配置好之后，继续点击 Next setup<br><img src="/images/pic/zabbix/zabbix-config004.png" alt><br>上图中，name尽量取有意义的名字，继续点击 Next setup<br><img src="/images/pic/zabbix/zabbix-config005.png" alt><br>到这一步可以看到全部配置，确认无误后点击 Next setup<br><img src="/images/pic/zabbix/zabbix-config006.png" alt><br>登录zabbix<br><img src="/images/pic/zabbix/zabbix-config007.png" alt><br>登录之后点击 <code>管理-用户-点击Admin</code> ，可以设置超级管理基本属性，例如语言和主题，点击<code>配置-主机</code> ，可以看到如下图，接下来安装zabbix客户端<br><img src="/images/pic/zabbix/zabbix-config008.png" alt></p><h2 id="安装zabbix-agent客户端"><a href="#安装zabbix-agent客户端" class="headerlink" title="安装zabbix agent客户端"></a>安装zabbix agent客户端</h2><blockquote><p>这里的客户端作用是监控服务端本机</p></blockquote><p>配置客户端，配置文件/etc/zabbix/zabbix_agentd.conf</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 主要配置如下，默认即可</span>Server<span class="token operator">=</span>127.0.0.1ServerActive<span class="token operator">=</span>127.0.0.1Hostname<span class="token operator">=</span>Zabbix server<span class="token comment" spellcheck="true"># 启动zabbix客户端</span>systemctl start zabbix-agent<span class="token comment" spellcheck="true"># 开机启动</span>systemctl <span class="token function">enable</span> zabbix-agent</code></pre><p>现在可以看到<code>可用性ZBX</code> 为绿色，表示的是zabbix-agent服务连接正常<br><img src="/images/pic/zabbix/zabbix-config009.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zabbix服务器监控之《初识zabbix概念》（一）</title>
      <link href="/2018/09/11/zabbix-summarize/"/>
      <url>/2018/09/11/zabbix-summarize/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要用Zabbix"><a href="#为什么要用Zabbix" class="headerlink" title="为什么要用Zabbix"></a>为什么要用Zabbix</h2><p>对于运维人员来说，监控是非常重要的，因为如果想要保证线上业务整体能够稳定运行，那么我们则需要实时关注与其相关的各项指标是否正常，而一个业务系统的背后，往往存在着很多的服务器、网络设备等硬件资源，如果我们想要能够更加方便的、集中的监控他们，我们则需要依靠一些外部的工具，而zabbix就是一个被广泛使用的，可以实现集中监控管理的应用程序。</p><h2 id="Zabbix支持那些通讯方式"><a href="#Zabbix支持那些通讯方式" class="headerlink" title="Zabbix支持那些通讯方式"></a>Zabbix支持那些通讯方式</h2><ul><li><code>agent</code> ：通过专用的代理程序进行监控，与常见的master/agent模型类似,如果被监控对象支持对应的agent，推荐首选这种方式。</li><li><code>ssh/telnet</code> ：通过远程控制协议进行通讯，比如ssh或者telnet。</li><li><code>SNMP</code> ：通过SNMP协议与被监控对象进行通讯，SNMP协议的全称为Simple Network Management Protocol ,被译为 “简单网络管理协议”，通常来说，我们无法在路由器、交换机这种硬件上安装agent，但是这些硬件往往都支持SNMP协议，SNMP是一种比较久远的、通行的协议，大部分网络设备都支持这种协议，其实SNMP协议的工作方式也可以理解为master/agent的工作方式，只不过是在这些设备中内置了SNMP的agent而已，所以，大部分网络设备都支持这种协议。</li><li><code>IPMI</code> ：通过IPMI接口进行监控，我们可以通过标准的IPMI硬件接口，监控被监控对象的物理特征，比如电压，温度，风扇状态，电源状态等。</li><li><code>JMX</code> ：通过JMX进行监控，JMX（Java Management Extensions，即Java管理扩展），监控JVM虚拟机时，使用这种方法也是非常不错的选择。</li></ul><h2 id="Zabbix监控流程"><a href="#Zabbix监控流程" class="headerlink" title="Zabbix监控流程"></a>Zabbix监控流程</h2><p>一般情况下，我们将zabbix agent部署到被监控主机上，由agent采集数据，报告给负责监控的中心主机，中心主机也就是master/agent模型中的master，负责监控的中心主机被称为zabbix server，zabbix server将从agent端接收到的信息存储于zabbix的数据库中，我们把zabbix的数据库端称为zabbix database， 如果管理员需要查看各种监控信息，则需要zabbix的GUI，zabbix的GUI是一种Web GUI，我们称之为zabbix web，zabbix web是使用php编写的，所以，如果想要使用zabbix web展示相关监控信息，需要依赖LAMP环境，不管是zabbix server ，或是zabbix web，他们都需要连接到zabbix database获取相关数据，这样说可能不容易理解，对比下图理解上述概念，就容易许多。<br><img src="/images/pic/zabbix/zabbix1.png" alt></p><p>当监控规模变得庞大时，我们可能有成千上万台设备需要监控，这时我们是否需要部署多套zabbix系统进行监控呢？如果部署多套zabbix监控系统，那么监控压力将会被分摊，但是，这些监控的对象将会被尽量平均的分配到不同的监控系统中，这个时候，我们就无法通过统一的监控入口，去监控这些对象了，虽然分摊了监控压力，但是也增加了监控工作的复杂度，那么，我们到底该不该建立多套zabbix监控系统从而分摊巨大的监控压力呢？其实，zabbix天生就有处理这种问题的能力，因为zabbix支持分布式监控，我们可以把成千上万台的被监控对象分成不同的区域，每个区域中设置一台代理主机，区域内的每个被监控对象的信息被agent采集，提交给代理主机，在这个区域内，代理主机的作用就好比zabbix server，我们称这些代理主机为zabbix proxy，zabbix proxy再将收集到的信息统一提交给真正的zabbix server处理，这样，zabbix proxy分摊了zabbix server的压力，同时，我们还能够通过统一的监控入口，监控所有的对象，当监控规模庞大到需要使用zabbix proxy时，zabbix的架构如下图，我们可以对比下图，理解上述描述。<br><img src="/images/pic/zabbix/zabbix2.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="zabbix核心组件"><a href="#zabbix核心组件" class="headerlink" title="zabbix核心组件"></a>zabbix核心组件</h3><ul><li><code>zabbix agent</code> ：部署在被监控主机上，负责被监控主机的数据，并将数据发送给zabbix server。</li><li><code>zabbix server</code> ：负责接收agent发送的报告信息，并且负责组织配置信息、统计信息、操作数据等。</li><li><code>zabbix database</code> ：用于存储所有zabbix的配置信息、监控数据的数据库。</li><li><code>zabbix proxy</code> ：可选组件，用于分布式监控环境中，zabbix proxy代表server端，完成局部区域内的信息收集，最终统一发往server端。</li></ul><h3 id="zabbix工作模式"><a href="#zabbix工作模式" class="headerlink" title="zabbix工作模式"></a>zabbix工作模式</h3><p>我们知道，agent端会将采集完的数据主动发送给server端，这种模式我们称之为主动模式，即对于agent端来说是主动的。<br>其实，agent端也可以不主动发送数据，而是等待server过来拉取数据，这种模式我们称之为被动模式。<br>但是，不管是主动模式还是被动模式，都是对于agent端来说的，而且，主动模式与被动模式可以同时存在，并不冲突。<br>管理员可以在agent端使用一个名为<code>zabbix_sender</code> 的工具，测试是否能够向server端发送数据。<br>管理员也可以在server端使用一个名为<code>zabbix_get</code> 的工具，测试是否能够从agent端拉取数据。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云ECS用465端口发邮件</title>
      <link href="/2018/03/25/aliyun-ecs-mail/"/>
      <url>/2018/03/25/aliyun-ecs-mail/</url>
      
        <content type="html"><![CDATA[<h3 id="原由"><a href="#原由" class="headerlink" title="原由"></a>原由</h3><p>大家可能都知道在阿里云购买的ECS云主机是不能直接通过25号端口发邮件的，因为阿里云底层对25号端口做了屏蔽。所以例如我们需要做监控、报告等邮件通知行为时，只能修改默认的25号端口。<br>下面我们就开始如何用465端口来发送邮件。</p><h3 id="请求数字证书"><a href="#请求数字证书" class="headerlink" title="请求数字证书"></a>请求数字证书</h3><ul><li><p>创建目录，用来存放证书</p><pre><code>[root@PLAY ~]# mkdir -p /root/.certs/[root@PLAY ~]# echo -n | openssl s_client -connect smtp.126.com:465 | sed -ne &#39;/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p&#39; &gt; ~/.certs/126.crtdepth=2 C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert Global Root CAverify return:1depth=1 C = US, O = DigiCert Inc, OU = www.digicert.com, CN = GeoTrust RSA CA 2018verify return:1depth=0 C = CN, L = Hangzhou, O = &quot;NetEase (Hangzhou) Network Co., Ltd&quot;, OU = Mail Dept., CN = *.126.comverify return:1DONE</code></pre><blockquote><p><code>smtp.126.com:465</code> 为发件者的邮件服务器，我这用的是网易<code>126.com</code> 邮箱。生成<code>126.crt</code> 的证书。</p></blockquote></li><li><p>添加一个证书到证书数据库中</p><pre><code>[root@PLAY ~]# certutil -A -n &quot;GeoTrust SSL CA&quot; -t &quot;C,,&quot; -d ~/.certs -i ~/.certs/126.crt[root@PLAY ~]# certutil -A -n &quot;GeoTrust Global CA&quot; -t &quot;C,,&quot; -d ~/.certs -i ~/.certs/126.crt</code></pre></li><li><p>列出目录下证书</p><pre><code>[root@PLAY ~]# certutil -L -d /root/.certsCertificate Nickname Trust AttributesSSL,S/MIME,JAR/XPIGeoTrust SSL CA C,,</code></pre><h3 id="获取126邮箱的授权码"><a href="#获取126邮箱的授权码" class="headerlink" title="获取126邮箱的授权码"></a>获取126邮箱的授权码</h3><p>前往邮箱的登陆网站登陆自己的邮箱，在邮箱设置里找到<code>POP3/SMTP/IMAP</code> 设置，并且完成客户端授权密码。如下图：<br><img src="/images/pic/shouquanma.png" alt="邮箱授权码"></p></li></ul><h3 id="配置-etc-mail-rc文件"><a href="#配置-etc-mail-rc文件" class="headerlink" title="配置/etc/mail.rc文件"></a>配置/etc/mail.rc文件</h3><p>在/etc/mail.rc文件末尾追加如下参数</p><pre><code>set bsdcompatset from=test_wly@126.comset smtp=&quot;smtps://smtp.126.com:465&quot;set smtp-auth-user=test_wly@126.comset smtp-auth-password=73jdi9dw7j3gc8gf1xvak01fssset smtp-auth=loginset ssl-verify=ignoreset nss-config-dir=/root/.certs</code></pre><h3 id="测试邮件发送是否正常"><a href="#测试邮件发送是否正常" class="headerlink" title="测试邮件发送是否正常"></a>测试邮件发送是否正常</h3><pre><code>[root@PLAY ~]# echo &quot;test mail&quot; | mail -s &quot;nagios report&quot; test_wly@126.com</code></pre><blockquote><p>如果配置正确，此时<a href="mailto:test_wly@126.com" target="_blank" rel="noopener">test_wly@126.com</a>就能收到刚刚发送的测试邮件了。</p></blockquote><p>看起来已经成功了，但是发送完邮件还有报错：证书不被信任，且命令行就此卡住，需要按键才能出现命令提示符<br><code>Error in certificate: Peer&#39;s certificate issuer is not recognized.</code><br>可以按如下操作即可解决问题：</p><pre><code>[root@PLAY ~]# cd /root/.certs/[root@PLAY .certs]# certutil -A -n &quot;GeoTrust SSL CA - G3&quot; -t &quot;Pu,Pu,Pu&quot; -d ./ -i 126.crt Notice: Trust flag u is set automatically if the private key is present.</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aliyun </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ansible 常用模块指令</title>
      <link href="/2018/03/22/ansible-module/"/>
      <url>/2018/03/22/ansible-module/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>本文主要讲解ansible的常用命令和简单安装步骤，具体配置文件详解以及playbook暂未涉及！后续更新。。。。</strong></p></blockquote><h3 id="安装Ansible"><a href="#安装Ansible" class="headerlink" title="安装Ansible"></a>安装Ansible</h3><pre class=" language-bash"><code class="language-bash">$ yum <span class="token function">install</span> epel-release ansible -y</code></pre><h3 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h3><ul><li>ansible.cfg文件<br>（主要设置一些ansible初始化的信息，比如日志存放路径、用户、模块、插件等配置信息）<pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/ansible/ansible.cfg <span class="token punctuation">[</span>defaults<span class="token punctuation">]</span>inventory <span class="token operator">=</span> /etc/ansible/hostslibrary <span class="token operator">=</span> /usr/share/ansiblesudo_user <span class="token operator">=</span> root  <span class="token punctuation">(</span>默认远程执行命令的用户<span class="token punctuation">)</span>remote_port <span class="token operator">=</span> 22fork <span class="token operator">=</span> 5host_key_checking <span class="token operator">=</span> Falselog_path <span class="token operator">=</span> /var/log/ansible.logmodule_name <span class="token operator">=</span> <span class="token function">command</span>roles_path <span class="token operator">=</span> /etc/ansible/rolesdeprecation_warnings <span class="token operator">=</span> False</code></pre></li><li>hosts 文件<br>（机器清单，进行分组管理）<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>tomcat<span class="token punctuation">]</span>192.168.16.192192.168.16.193<span class="token punctuation">[</span>nginx<span class="token punctuation">]</span>app1 ansible_ssh_host<span class="token operator">=</span>192.168.16.190 ansible_ssh_pass<span class="token operator">=</span><span class="token string">"2039"</span>app2 ansible_ssh_host<span class="token operator">=</span>192.168.16.191 sudo_user<span class="token operator">=</span>”ald” ansible_ssh_pass<span class="token operator">=</span><span class="token string">"2039"</span></code></pre><blockquote><p><em>sudo_user和ansible_ssh_pass为帐号密码方式验证，建议用密钥。</em></p></blockquote><h3 id="Ansible指令参数"><a href="#Ansible指令参数" class="headerlink" title="Ansible指令参数"></a>Ansible指令参数</h3></li><li><p><strong>ansible 常用命令参数</strong><br>-m指定模块<br>-a 指定模块的命令。默认是command模块，可以省略<br>-B 指定ansible后台运行超时时间<br>-C 测试运行效果，而不是正在运行<br>-f 指定使用的并行进程的数量<br>-i 指定inventory/hosts文件，默认/etc/ansiable/hosts文件<br>–limit=xxx.xxx.xxx.xxx 限制对某个ip或者网段或者组执行<br>–list-hosts 显示将要执行命令的主机</p></li><li><p><strong>ansible-doc 常用命令参数</strong><br>-M –module-path=/xxx/xxx  查询模块 默认是/usr/share/ansible/<br>-l  –list          显示已存在的所有模块<br>-s  command     显示playbook制定模块的用法，类似 man 命令</p></li><li><p><strong>ansible-galaxy</strong> </p><blockquote><p>下载第三方模块指令，类似yum、pip、easy_install这样的命令</p></blockquote><p> ansible-galaxy install &lt;module_name&gt;</p></li><li><p><strong>ansible-playbook</strong> 常用命令参数<br>–syntax-check  [yaml文件]         语法检测<br>-t TAGS    只允许指定的tags标签任务，多个以 , 分开<br>–skip-tags=SKIP_TAGS   跳过指定的标签<br>–start-at-task=START_AT   从哪个任务后执行</p></li></ul><h3 id="常用指令模块"><a href="#常用指令模块" class="headerlink" title="常用指令模块"></a>常用指令模块</h3><p>1、 copy——拷贝模块   (用于将本地或远程机器上的文件拷贝到远程主机上)</p><pre class=" language-bash"><code class="language-bash">$ ansible all –m copy -a “src<span class="token operator">=</span>/xxx/xxx dest<span class="token operator">=</span>/yyy/yyy owner<span class="token operator">=</span>root group<span class="token operator">=</span>root mode<span class="token operator">=</span>644 force<span class="token operator">=</span>yes/no backup<span class="token operator">=</span>yes/no”解释：将src 文件/目录复制到远程dest上，所有者/组为root 权限为644，force为是否强制替换，backup为替换前是否需要备份远程远文件</code></pre><p>2、 raw——命令模块 （和command、shell类似）</p><pre class=" language-bash"><code class="language-bash">$ ansible all –m raw -a <span class="token string">"ifconfig"</span>解释：在所有主机上执行ifocnfig命令。</code></pre><p>3、 yum——安装模块 （安装程序）</p><pre class=" language-bash"><code class="language-bash">$ ansible all –m yum –a “name<span class="token operator">=</span>httpd state<span class="token operator">=</span>present”解释：安装httpd程序，state可以是present、latest、installed表示安装程序，absent、removed表示卸载程序</code></pre><p>4、 file——文件模块 （文件属性修改）</p><pre class=" language-bash"><code class="language-bash">$ ansible all –m <span class="token function">file</span> –a “src<span class="token operator">=</span>/xxx/xxx/1 dest<span class="token operator">=</span>/yyy/1 state<span class="token operator">=</span>link owner<span class="token operator">=</span>alad group<span class="token operator">=</span>alad mode<span class="token operator">=</span>777”$ ansible develop -m <span class="token function">file</span> -a <span class="token string">"path=/xxx/dir recurse=yes owner=root group=alad mode=644"</span>解释：1、将src的文件软连接到dest目录下，并修改所有者/组和权限      2、将path路径的目录递归形式设置所有者和权限*、state还可以是directory：如果目录不存在，创建目录    file：即使文件不存在，也不会被创建    hard：创建硬链接    touch：如果文件不存在，则会创建一个新的文件，如果文件或目录已存在，则更新其最后修改时间    absent：删除目录、文件或者取消链接文件</code></pre><p>5、 cron——计划任务模块 （计划任务crontab）</p><pre class=" language-bash"><code class="language-bash">$ ansible develop -m <span class="token function">cron</span> -a <span class="token string">"name='show time' minute=*/1 hour=* day=* month=* weekday=* job='/bin/date'"</span>$ ansible develop -m <span class="token function">cron</span> -a <span class="token string">"name='show time' state=absent"</span>解释：1、创建一个每分钟显示时间的计划任务      2、删除名为show time这个计划任务</code></pre><p>6、 group——组模块（用户组）</p><pre class=" language-bash"><code class="language-bash">$ ansible all-m group -a <span class="token string">"name=develop"</span>解释：在所有主机上创建一个develop的组 ，state<span class="token operator">=</span>absent表示删除该组</code></pre><p>7、 user——用户模块（用户）</p><pre class=" language-bash"><code class="language-bash">$ ansible develop -m user -a <span class="token string">"name=harlan groups=root password=-1vFO89dP6qyK"</span>$ ansible develop -m user -a <span class="token string">"name=harlan state=absent remove=yes"</span>解释：1、在所有主机上创建harlan用户，并将其添加到root组，密码是经过hash加密后的，明文密码会被哈希，所以先填入hash后的密码即可可用此命令hash密码  openssl <span class="token function">passwd</span> -salt -1 <span class="token string">"123456"</span>      2、删除harlan用户。Remove表示是否删除用户的同时删除家目录</code></pre><p>8、 service——服务模块（服务状态）</p><pre class=" language-bash"><code class="language-bash">$ ansible develop -m <span class="token function">service</span> -a <span class="token string">"name=nginx state=running"</span>$ ansible develop -m <span class="token function">service</span> -a <span class="token string">"name=nginx state=restarted enabled=yes"</span>解释：1、无论服务处在什么状态，最后都是将服务状态设置为启动，当服务正在运行的时候，显示为changed为false，state显示为状态，表示为正在运行；当服务停止的时候，显示为changed为true，表示这个时候将服务进行了启动，状态为启动      2、表示重启nginx并且将nginx设置为开机自启动，state还有staeted、reloaded、stoped值</code></pre><p>9、 script——脚本模块（运行脚本）</p><pre class=" language-bash"><code class="language-bash">$ ansible develop -m script -a <span class="token string">"/root/a.sh"</span>解释：在develop主机上运行当前服务器上的a.sh脚本</code></pre><p>10、get_url——下载url上指定文件（类似wget）</p><pre class=" language-bash"><code class="language-bash">$ ansible develop -m get_url -a <span class="token string">"url=http://file.alavening.com/alading_file/head_img/1526900421976.jpg dest=/home/ owner=alad group=alad mode=644"</span>解释：将url上的图片下载到dest目的目录上,并且设置相应的所有者/组和权限。</code></pre><p>11、synchronize——同步目录（默认推送，mode=pull为拉取）</p><pre class=" language-bash"><code class="language-bash">$ ansible develop -m synchronize -a <span class="token string">"src=/home/test/ dest=/home/test compress=yes delete=yes"</span>$ ansible develop -m synchronize -a <span class="token string">"src=/home/test/ dest=/home/test compress=yes mode=pull"</span>解释：1、将src下的文件同步到dest上，delete<span class="token operator">=</span>yes表示以src 目录为准镜像同步。      2、拉取远程src上的目录文件到本地dest上</code></pre><p>12、template——文档内变量的替换的模块</p><pre class=" language-bash"><code class="language-bash">$ ansible develop –m template –a ‘src<span class="token operator">=</span>/mytemplates/foo.j2 dest<span class="token operator">=</span>/etc/file.conf mode<span class="token operator">=</span><span class="token string">"u=rw,g=r,o=r"</span>’解释：将src上foo.j2的变量模版复制到dest上。Template适合用playbook编写 ，通过变量然后拷贝到远程主机。</code></pre><blockquote><p>可以参考：<a href="https://www.cnblogs.com/jsonhc/p/7895399.html" target="_blank" rel="noopener">https://www.cnblogs.com/jsonhc/p/7895399.html</a></p></blockquote><p>13、fetch——从远程主机下载文件（不能拉取目录）</p><pre class=" language-bash"><code class="language-bash">$ ansible develop -m fetch -a <span class="token string">"src=/home/test/xxx dest=/home/ flat=yes"</span>解释：将远程xxx文件拉取到本地home目录下，目录结构会是dest路径+远程主机名+src，假如远程主机名为develop，拉取的xxx文件在本地的/home/develop/home/test目录。如果需要指定拉取到某目录下 加个flat<span class="token operator">=</span>yes的参数即可。</code></pre><p>14、unarchive——解压文件</p><pre class=" language-bash"><code class="language-bash">$ ansible develop -m unarchive -a <span class="token string">"src=/root/apache-tomcat-7.0.85.tar.gz dest=/home/test owner=alad group=alad mode=755"</span>$ ansible develop -m unarchive -a <span class="token string">"src=/home/alad/ansible/elk/logstash-6.2.4.tar.gz dest=/home/test remote_src=yes"</span>$ ansible develop -m unarchive -a <span class="token string">"src=http://mirrors.linuxeye.com/oneinstack-full.tar.gz dest=/home/test remote_src=yes"</span>解释：将本地的tomcat压缩包解压到远程主机dest目录下，并修改其权限和所有者/组，remote_src<span class="token operator">=</span>yes 表示解压远程主机已有的压缩包，src为url表示下载此包到远程主机dest目录进行解压缩后，并删除压缩包源文件</code></pre><p>15、command和shell——linux命令模块</p><pre><code>shell和command的区别：shell模块可以特殊字符，而command是不支持简单说：command运行的命令中无法使用变量，管道。如果需要使用管道、变量，请使用raw模块,或者shell模块。</code></pre><p>16、setup——获取主机信息</p><pre class=" language-bash"><code class="language-bash">$ ansible develop -m setup$ ansible develop -m setup -a <span class="token string">'filter=ansible_*_mb'</span>解释：1、显示系统所有信息      2、通常配合filter进行过滤来获取主机信息，（例子是显示内存信息）</code></pre><p>17、assemble——配置文件组装发送到远程主机</p><pre class=" language-bash"><code class="language-bash">$ ansible <span class="token function">test</span> -m assemble -a <span class="token string">"src=/root/test dest=/root/ansible/fileone mode=777 remote_src=False delimiter='========'"</span>解释：将src test目录下所有文件（不含test子目录内容）的内容发送到dest fileone文件中，remote_src默认为Ture表示src为远程主机上的路径，False为ansible控制端的路径，delimiter为文件之间内容分隔符。</code></pre><h3 id="Playbook语法和结构"><a href="#Playbook语法和结构" class="headerlink" title="Playbook语法和结构"></a>Playbook语法和结构</h3><p>Playbook需要7个文件夹，如ansible安装nginx，则需要在/etc/ansible/roles目录下建立以下文件夹。<br>mkdir -pv nginx/{default,tasks,vars,meta,handlers,templates,files}<br>对于Ansible，几乎每个YAML文件都以一个列表开始。列表中的每个项目都是键/值对列表，通常称为“散列”或“字典”。所以，我们需要知道如何在YAML中编写列表和字典。<br>YAML还有一个小小的怪癖。所有YAML文件（无论它们是否与Ansible相关联）都可以选择开始—和结束—.。这是YAML格式的一部分，并指示文档的开始和结束。<br>列表中的所有成员都是以相同的缩进级别开头的行（短划线和空格）：”- “</p><p>例如：</p><pre class=" language-yaml"><code class="language-yaml">    <span class="token punctuation">---</span>    <span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> test      <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root      <span class="token key atrule">vars</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">bsh</span><span class="token punctuation">:</span> b.sh        <span class="token punctuation">-</span> <span class="token key atrule">httprpm</span><span class="token punctuation">:</span> httpd      <span class="token key atrule">task</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> install httpd          <span class="token key atrule">yum</span><span class="token punctuation">:</span> name=<span class="token punctuation">{</span><span class="token punctuation">{</span> httprpm <span class="token punctuation">}</span><span class="token punctuation">}</span> state=present”          <span class="token key atrule">tags</span><span class="token punctuation">:</span> install_httpd        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> copy b.sh          <span class="token key atrule">copy</span><span class="token punctuation">:</span> src=/root/<span class="token punctuation">{</span><span class="token punctuation">{</span> bsh <span class="token punctuation">}</span><span class="token punctuation">}</span> dest=/root/ owner=ala group=ala mode=0644          <span class="token key atrule">notify</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> reload httpd        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> start httpd          <span class="token key atrule">service</span><span class="token punctuation">:</span> name=httpd state=started enabled=yes      <span class="token key atrule">handlers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> reload httpd          <span class="token key atrule">service</span><span class="token punctuation">:</span> name=httpd state=reloaded</code></pre><p>第一次的话都会运行，后边如果copy的文件内容发生改变就会触发 notify ，然后会直接执行 handlers 的内容（ 这里notify后边的事件就都不会执行了 ）。</p><h3 id="template模块jinja2语法"><a href="#template模块jinja2语法" class="headerlink" title="template模块jinja2语法"></a>template模块jinja2语法</h3><ul><li><strong>template:使用了Jinjia2格式作为文件模版，进行文档内变量的替换的模块。相当于copy，将jinja2的文件模板理解并执行，转化为各个主机间的对应值。</strong><br>如：template: src=httpd.conf.j2 dest=/etc/httpd/conf/httpd.conf</li></ul><blockquote><p>http.conf.j2必须是完整的文件内容，因为这是覆盖操作，而非只选择性远程主机替换变量，dest要指定文件名，如果是目录就相当于copy了http.conf.j2到远程目录下，不是我们要的结果。</p></blockquote><ul><li><strong>when语句：在tasks中使用，Jinja2的语法格式</strong></li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> start nginx service <span class="token key atrule">shell</span><span class="token punctuation">:</span> systemctl start nginx.service <span class="token key atrule">when</span><span class="token punctuation">:</span> ansible_distribution == "CentOS" and ansible_distribution_major_version == "7"</code></pre><p>当系统为 centos 7的时候执行sysctemctl命令，否则不执行</p><ul><li><strong>循环：迭代，需要重复执行的任务</strong></li></ul><blockquote><p>变量名为item，而with_item为要迭代的元素。如果某个任务出错，后面不执行</p></blockquote><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> install packages <span class="token key atrule">yum</span><span class="token punctuation">:</span> name=<span class="token punctuation">{</span><span class="token punctuation">{</span> item <span class="token punctuation">}</span><span class="token punctuation">}</span> state=latest <span class="token key atrule">with_items</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> httpd    <span class="token punctuation">-</span> php</code></pre><blockquote><p>这是基于字符串列表给出元素示例 </p></blockquote><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> create users    <span class="token key atrule">user</span><span class="token punctuation">:</span> name=<span class="token punctuation">{</span><span class="token punctuation">{</span> item.name <span class="token punctuation">}</span><span class="token punctuation">}</span> group=<span class="token punctuation">{</span><span class="token punctuation">{</span> item.group <span class="token punctuation">}</span><span class="token punctuation">}</span> state=present    <span class="token key atrule">with_items</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token punctuation">{</span><span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">'userx1'</span><span class="token punctuation">,</span> <span class="token key atrule">group</span><span class="token punctuation">:</span> <span class="token string">'groupx1'</span><span class="token punctuation">}</span>    <span class="token punctuation">-</span> <span class="token punctuation">{</span><span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">'userx2'</span><span class="token punctuation">,</span> <span class="token key atrule">group</span><span class="token punctuation">:</span> <span class="token string">'groupx2'</span><span class="token punctuation">}</span></code></pre><p>这是基于字典列表给元素示例：item.name  . 后边的表示键。</p>]]></content>
      
      
      <categories>
          
          <category> CI/CD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ansible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx内置变量</title>
      <link href="/2018/01/23/nginx-variable/"/>
      <url>/2018/01/23/nginx-variable/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx-内置变量解释"><a href="#Nginx-内置变量解释" class="headerlink" title="Nginx 内置变量解释"></a>Nginx 内置变量解释</h2><p>为了方便配置和使用nginx，nginx核心模块ngx_http_core_module自带有许多内置的人性化变量，这极大的方便了系统管理员对nginx维护和管理。下面我们详解注解内置变量的含义（当然，如果你懂点HTTP知识的话，就更好理解了）：</p><pre><code>$args                    #请求中的参数值$query_string            #同 $args$arg_NAME                #GET请求中NAME的值$is_args                 #如果请求中有参数，值为&quot;?&quot;，否则为空字符串$uri                     #请求中的当前URI(不带请求参数，参数位于$args)，可以不同于浏览器传递的$request_uri的值，它可以通过内部重定向，或者使用index指令进行修改，$uri不包含主机名，如&quot;/foo/bar.html&quot;。$document_uri            #同 $uri$document_root           #当前请求的文档根目录或别名$host                    #优先级：HTTP请求行的主机名&gt;&quot;HOST&quot;请求头字段&gt;符合请求的服务器名$hostname                #主机名$https                   #如果开启了SSL安全模式，值为&quot;on&quot;，否则为空字符串。$binary_remote_addr      #客户端地址的二进制形式，固定长度为4个字节$body_bytes_sent         #传输给客户端的字节数，响应头不计算在内；这个变量和Apache的mod_log_config模块中的&quot;%B&quot;参数保持兼容$bytes_sent              #传输给客户端的字节数$connection              #TCP连接的序列号$connection_requests     #TCP连接当前的请求数量$content_length          #&quot;Content-Length&quot; 请求头字段$content_type            #&quot;Content-Type&quot; 请求头字段$cookie_name             #cookie名称$limit_rate              #用于设置响应的速度限制$msec                    #当前的Unix时间戳$nginx_version           #nginx版本$pid                     #工作进程的PID$pipe                    #如果请求来自管道通信，值为&quot;p&quot;，否则为&quot;.&quot;$proxy_protocol_addr     #获取代理访问服务器的客户端地址，如果是直接访问，该值为空字符串$realpath_root           #当前请求的文档根目录或别名的真实路径，会将所有符号连接转换为真实路径$remote_addr             #客户端地址$remote_port             #客户端端口$remote_user             #用于HTTP基础认证服务的用户名$request                 #代表客户端的请求地址$request_body            #客户端的请求主体：此变量可在location中使用，将请求主体通过proxy_pass，fastcgi_pass，uwsgi_pass和scgi_pass传递给下一级的代理服务器$request_body_file       #将客户端请求主体保存在临时文件中。文件处理结束后，此文件需删除。如果需要之一开启此功能，需要设置client_body_in_file_only。如果将次文件传递给后端的代理服务器，需要禁用request body，即设置proxy_pass_request_body off，fastcgi_pass_request_body off，uwsgi_pass_request_body off，or scgi_pass_request_body off$request_completion      #如果请求成功，值为&quot;OK&quot;，如果请求未完成或者请求不是一个范围请求的最后一部分，则为空$request_filename        #当前连接请求的文件路径，由root或alias指令与URI请求生成$request_length          #请求的长度 (包括请求的地址，http请求头和请求主体)$request_method          #HTTP请求方法，通常为&quot;GET&quot;或&quot;POST&quot;$request_time            #处理客户端请求使用的时间; 从读取客户端的第一个字节开始计时$request_uri             #这个变量等于包含一些客户端请求参数的原始URI，它无法修改，请查看$uri更改或重写URI，不包含主机名，例如：&quot;/cnphp/test.php?arg=freemouse&quot;$scheme                  #请求使用的Web协议，&quot;http&quot; 或 &quot;https&quot;$server_addr             #服务器端地址，需要注意的是：为了避免访问linux系统内核，应将ip地址提前设置在配置文件中$server_name             #服务器名$server_port             #服务器端口$server_protocol         #服务器的HTTP版本，通常为 &quot;HTTP/1.0&quot; 或 &quot;HTTP/1.1&quot;$status                  #HTTP响应代码$time_iso8601            #服务器时间的ISO 8610格式$time_local              #服务器时间（LOG Format 格式）$cookie_NAME             #客户端请求Header头中的cookie变量，前缀&quot;$cookie_&quot;加上cookie名称的变量，该变量的值即为cookie名称的值$http_NAME               #匹配任意请求头字段；变量名中的后半部分NAME可以替换成任意请求头字段，如在配置文件中需要获取http请求头：&quot;Accept-Language&quot;，$http_accept_language即可$http_cookie$http_post$http_referer            #url跳转来源 （https://www.baidu.com/）$http_user_agent        #用户终端浏览器等信息 （&quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; GTB7.0; .NET4.0C;）$http_x_forwarded_for    #获取到最原始用户IP，或者代理IP地址。$sent_http_NAME            #可以设置任意http响应头字段；变量名中的后半部分NAME可以替换成任意响应头字段，如需要设置响应头Content-length，$sent_http_content_length即可$upstream_response_time    #请求过程中，upstream响应时间（0.002）$upstream_addr            #后台upstream的地址，即真正提供服务的主机地址 （10.10.10.100:80）$upstream_status        #upstream状态 （200）$sent_http_cache_control$sent_http_connection$sent_http_content_type$sent_http_keep_alive$sent_http_last_modified$sent_http_location$sent_http_transfer_encoding</code></pre><p>这些变量可以在配置文件中使用，方便你做各种nginx页面代理，转换，重写，重定向等操作；而且还可以对nginx日志做自定义的日志配置，方便你对nginx日志的收集和分析。如常用的nginx日志格式：</p><pre><code>log_format  main  &#39;$remote_addr $remote_user [$time_local] &quot;$request&quot; &#39;                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                  &#39;$http_user_agent $http_x_forwarded_for $request_time $upstream_response_time $upstream_addr $upstream_status&#39;;</code></pre><p>日志截取如下（可以从日志中看到代理到后端哪台机器上的哪个端口上，负载访问的状态值等都能看到）：</p><pre><code>[root@nginx1 logs]# tail -f /data/wwwlogs/access.log...110.156.114.121 - [11/Aug/2017:09:57:19 +0800] &quot;GET /rest/mywork/latest/status/notification/count?_=1502416641768 HTTP/1.1&quot; 200 67 &quot;http://wiki.wang-inc.com/pages/viewpage.action?pageId=11174759&quot; Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.78 Safari/537.36 - 0.006 0.006 12.129.120.121:8090 200</code></pre>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解nginx之location误区</title>
      <link href="/2018/01/23/nginx-location/"/>
      <url>/2018/01/23/nginx-location/</url>
      
        <content type="html"><![CDATA[<h3 id="location-的匹配顺序是“先匹配正则，再匹配普通”。"><a href="#location-的匹配顺序是“先匹配正则，再匹配普通”。" class="headerlink" title="location 的匹配顺序是“先匹配正则，再匹配普通”。"></a>location 的匹配顺序是“先匹配正则，再匹配普通”。</h3><p>矫正： location 的匹配顺序其实是“先匹配普通，再匹配正则”。我这么说，大家一定会反驳我，因为按“先匹配普通，再匹配正则”解释不了大家平时习惯的按“先匹配正则，再匹配普通”的实践经验。这里我只能暂时解释下，造成这种误解的原因是：正则匹配会覆盖普通匹配（实际的规则，比这复杂，后面会详细解释）。</p><h3 id="location-的执行逻辑跟-location-的编辑顺序无关。"><a href="#location-的执行逻辑跟-location-的编辑顺序无关。" class="headerlink" title="location 的执行逻辑跟 location 的编辑顺序无关。"></a>location 的执行逻辑跟 location 的编辑顺序无关。</h3><p>矫正：这句话不全对，“普通 location ”的匹配规则是“最大前缀”，因此“普通 location ”的确与 location 编辑顺序无关；但是“正则 location ”的匹配规则是“顺序匹配，且只要匹配到第一个就停止后面的匹配”；“普通location ”与“正则 location ”之间的匹配顺序是？先匹配普通 location ，再“考虑”匹配正则 location 。注意这里的“考虑”是“可能”的意思，也就是说匹配完“普通 location ”后，有的时候需要继续匹配“正则 location ”，有的时候则不需要继续匹配“正则 location ”。两种情况下，不需要继续匹配正则 location ：（ 1 ）当普通 location 前面指定了“ ^~ ”，特别告诉 Nginx 本条普通 location 一旦匹配上，则不需要继续正则匹配；（ 2 ）当普通location 恰好严格匹配上，不是最大前缀匹配，则不再继续匹配正则。</p><p><strong>总结一句话：  “正则 location 匹配让步普通 location 的严格精确匹配结果；但覆盖普通 location 的最大前缀匹配结果”</strong></p><blockquote><p>匹配优先级为： (location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/)</p></blockquote><p><strong>官方文档解释</strong>：<a href="http://wiki.nginx.org/NginxHttpCoreModule#location" target="_blank" rel="noopener">http://wiki.nginx.org/NginxHttpCoreModule#location</a></p><pre><code>locationsyntax: `location [=|~|~*|^~|@] /uri/ { … }`default: nocontext: server</code></pre><blockquote><p>This directive allows different configurations depending on the URI.</p></blockquote><p>（译者注：1 、different configurations depending on the URI 说的就是语法格式：<code>location [=|~|~*|^~|@] /uri/ { … }</code> ，依据不同的前缀<code>“= ”，“^~ ”，“~ ”，“~* ”</code>和不带任何前缀的（因为[A] 表示可选，可以不要的），表达不同的含义, 简单的说尽管location 的/uri/ 配置一样，但前缀不一样，表达的是不同的指令含义。2 、查询字符串不在URI范围内。例如：/films.htm?fid=123 的URI 是/films.htm 。）<br>It can be configured using both literal strings and regular expressions. To use regular expressions, you must use a prefix:<br><code>“~”</code>for case sensitive matching<br><code>“~*”</code>for case insensitive matching<br>译文：上文讲到<code>location /uri/</code> 可通过使用不同的前缀，表达不同的含义。对这些不同前缀，分下类，就2 大类：正则location ，英文说法是location using regular expressions 和普通location ，英文说法是location using literal strings 。那么其中“~ ”和“~<em> ”前缀表示正则location ，“~ ”区分大小写，“~</em> ”不区分大小写；其他前缀（包括：“=”，“^~ ”和“@ ”）和无任何前缀的都属于普通location 。</p><blockquote><p>To determine which location directive matches a particular query, the literal strings are checked first.</p></blockquote><p>译文：对于一个特定的 HTTP 请求（ a particular query ）， nginx 应该匹配哪个 location 块的指令呢（注意：我们在 nginx.conf 配置文件里面一般会定义多个 location 的）？匹配 规则是：先匹配普通location （再匹配正则表达式）。注意：官方文档这句话就明确说了，先普通location ，而不是有些同学的误区“先匹配正则location ”。</p><blockquote><p>Literal strings match the beginning portion of the query – the most specific match will be used.</p></blockquote><p>前面说了“普通location ”与“正则location ”之间的匹配规则是：先匹配普通location ，再匹配正则location 。那么，“普通location ”内部（普通location 与普通location ）是如何匹配的呢？简单的说：最大前缀匹配。原文：1、match the beginning portion of the query （说的是匹配URI 的前缀部分beginning portion ）； 2 、the most specific match will be used （因为location 不是“严格匹配”，而是“前缀匹配”，就会产生一个HTTP 请求，可以“前缀匹配”到多个普通location ，例如：<code>location /prefix/mid/ {}</code> 和<code>location /prefix/ {}</code> ，对于HTTP 请求/prefix/mid/t.html ，前缀匹配的话两个location 都满足，选哪个？原则是：the most specific match ，于是选的是<code>location /prefix/mid/ {}</code> ）。</p><blockquote><p>Afterwards, regular expressions are checked in the order defined in the configuration file. The first regular expression to match the query will stop the search.</p></blockquote><p>这段话说了两层意思，第一层是：“Afterwards, regular expressions are checked ”, 意思是普通location 先匹配，而且选择了最大前缀匹配后，就不能停止后面的匹配，最大前缀匹配只是一个临时的结果，nginx 还需要继续检查正则location （但至于最终是和普通location 的最大前缀匹配，还是正则location 的匹配，截止当前的内容还没讲，但后面会讲）。第二层是“regular expressions are checked in the order defined in the configuration file. The first regular expression to match the query will stop the search. ”，意思是说“正则location ”与“正则location”内部的匹配规则是：按照正则location 在配置文件中的物理顺序（编辑顺序）匹配的（这句话就说明location 并不是一定跟顺序无关，只是普通location 与顺序无关，正则location 还是与顺序有关的），并且只要匹配到一条正则location ，就不再考虑后面的（这与“普通location ”与“正则location ”之间的规则不一样，“普通location ”与“正则location ”之间的规则是：选择出“普通location ”的最大前缀匹配结果后，还需要继续搜索正则location ）。</p><blockquote><p>If no regular expression matches are found, the result from the literal string search is used.</p></blockquote><p>这句话回答了“普通location ”的最大前缀匹配结果与继续搜索的“正则location ”匹配结果的决策关系。如果继续搜索的“正则location ”也有匹配上的，那么“正则location ”覆盖 “普通location ”的最大前缀匹配（因为有这个覆盖关系，所以造成有些同学以为正则location 先于普通location 执行的错误理解）；但是如果“正则location ”没有能匹配上，那么就用“普通location ”的最大前缀匹配结果。<br>For case insensitive operating systems, like Mac OS X or Windows with Cygwin, literal string matching is done in a case insensitive way (0.7.7). However, comparison is limited to single-byte locale’s only.<br>Regular expression may contain captures (0.7.40), which can then be used in other directives.</p><blockquote><p>It is possible to disable regular expression checks after literal string matching by using “^~” prefix.If the most specific match literal location has this prefix: regular expressions aren’t checked.</p></blockquote><p>通常的规则是，匹配完了“普通location ”指令，还需要继续匹配“正则location ”，但是你也可以告诉Nginx ：匹配到了“普通location ”后，不再需要继续匹配“正则location ”了，要做到这一点只要在“普通location ”前面加上“^~ ”符号（^ 表示“非”，~ 表示“正则”，字符意思是：不要继续匹配正则）。</p><blockquote><p>By using the “=” prefix we define the exact match between request URI and location. When matched search stops immediately. E.g., if the request “/” occurs frequently, using “location = /” will speed up processing of this request a bit as search will stop after first comparison.</p></blockquote><p>除了上文的“^~ ”可以阻止继续搜索正则location 外，你还可以加“= ”。那么如果“^~ ”和“= ”都能阻止继续搜索正则location 的话，那它们之间有什么区别呢？区别很简单，共同点是它们都能阻止继续搜索正则location ，不同点是“^~ ”依然遵守“最大前缀”匹配规则，然而“= ”不是“最大前缀”，而是必须是严格匹配（exact match ）。<br>这里顺便讲下<code>“location / {} ”和“location = / {} ”</code>的区别，“location / {} ”遵守普通location 的最大前缀匹配，由于任何URI 都必然以“/ ”根开头，所以对于一个URI ，如果有更specific 的匹配，那自然是选这个更specific 的，如果没有，“/ ”一定能为这个URI 垫背（至少能匹配到“/ ”），也就是说“location / {} ”有点默认配置的味道，其他更specific的配置能覆盖overwrite 这个默认配置（这也是为什么我们总能看到location / {} 这个配置的一个很重要的原因）。而“location = / {} ”遵守的是“严格精确匹配exact match ”，也就是只能匹配 <a href="http://host:port/" target="_blank" rel="noopener">http://host:port/</a> 请求，同时会禁止继续搜索正则location 。因此如果我们只想对“GET / ”请求配置作用指令，那么我们可以选“location = / {} ”这样能减少正则location 的搜索，因此效率比“location / {}” 高（注：前提是我们的目的仅仅只想对“GET / ”起作用）。</p><blockquote><p>On exact match with literal location without “=” or “^~” prefixes search is also immediately terminated.</p></blockquote><p>前面我们说了，普通location 匹配完后，还会继续匹配正则location ；但是nginx 允许你阻止这种行为，方法很简单，只需要在普通location 前加“^~ ”或“= ”。但其实还有一种“隐含”的方式来阻止正则location 的搜索，这种隐含的方式就是：当“最大前缀”匹配恰好就是一个“严格精确（exact match ）”匹配，照样会停止后面的搜索。原文字面意思是：只要遇到“精确匹配exact match ”，即使普通location 没有带“= ”或“^~ ”前缀，也一样会终止后面的匹配。</p><p>先举例解释下，后面例题会用实践告诉大家。假设当前配置是：location /exact/match/test.html { 配置指令块1}，location /prefix/ { 配置指令块2} 和 location ~ .html$ { 配置指令块3} ，如果我们请求 GET /prefix/index.html ，则会被匹配到指令块3 ，因为普通location /prefix/ 依据最大匹配原则能匹配当前请求，但是会被后面的正则location 覆盖；当请求GET /exact/match/test.html ，会匹配到指令块1 ，因为这个是普通location 的exact match ，会禁止继续搜索正则location 。</p><p><strong>To summarize, the order in which directives are checked is as follows:</strong></p><ol><li>Directives with the “=” prefix that match the query exactly. If found, searching stops.</li><li>All remaining directives with conventional strings. If this match used the “^~” prefix, searching stops.</li><li>Regular expressions, in the order they are defined in the configuration file.</li><li>If #3 yielded a match, that result is used. Otherwise, the match from #2 is used.</li></ol><p>这个顺序没必要再过多解释了。但我想用自己的话概括下上面的意思“正则 location 匹配让步普通location 的严格精确匹配结果；但覆盖普通 location 的最大前缀匹配结果”。</p><blockquote><p>It is important to know that nginx does the comparison against decoded URIs. For example, if you wish to match “/images/ /test”, then you must use “/images/ /test” to determine the location.</p></blockquote><p>在浏览器上显示的URL 一般都会进行URLEncode ，例如“空格”会被编码为  ，但是Nginx 的URL 的匹配都是针对URLDecode 之后的。也就是说，如果你要匹配“/images/ /test ”，你写location 的时候匹配目标应该是：“/images/ /test ”。</p><p><strong>Example:</strong></p><pre><code>location   = / { # matches the query / only. [ configuration A ]}location   / {  # matches any query, since all queries begin with /, but regular  # expressions and any longer conventional blocks will be  # matched first. [ configuration B ]}location ^~ /images/ {    # matches any query beginning with /images/ and halts searching,    # so regular expressions will not be checked. [ configuration C ]}location ~* \.(gif|jpg|jpeg)$ { # matches any request ending in gif, jpg, or jpeg. However, all # requests to the /images/ directory will be handled by # Configuration C.   [ configuration D ]}</code></pre><p>上述这4 个location 的配置，没什么好解释的，唯一需要说明的是location / {[configuration B]} ，原文的注释严格来说是错误的，但我相信原文作者是了解规则的，只是文字描述上简化了下，但这个简化容易给读者造成“误解：先检查正则location ，再检查普通location ”。原文：“matches any query, since all queries begin with /, butregular expressions and any longer conventional blocks will be matched first. ”大意是说：“location / {} 能够匹配所有HTTP 请求，因为任何HTTP 请求都必然是以‘/ ’开始的（这半句没有错误）。但是，正则location 和其他任何比‘/ ’更长的普通location （location / {} 是普通location 里面最短的，因此其他任何普通location 都会比它更长，当然location = / {} 和 location ^~ / {} 是一样长的）会优先匹配（matched first ）。” 原文作者说“ but regular expressions will be matched first. ”应该只是想说正则 location 会覆盖这里的 location / {} ，但依然是普通location / {} 先于正则 location 匹配，接着再正则 location 匹配；但其他更长的普通 location （ any longer conventional blocks ）的确会先于 location / {} 匹配。</p><p>Example requests:</p><ul><li>/ -&gt; configuration A</li><li>/documents/document.html -&gt; configuration B</li><li>/images/1.gif -&gt; configuration C</li><li>/documents/1.jpg -&gt; configuration D</li></ul><blockquote><p>Note that you could define these 4 configurations in any order and the results would remain the same.</p></blockquote><p>需要提醒下：这里说“in any order ”和“… remain the same ”是因为上面只有一个正则location 。文章前面已经说了正则location 的匹配是跟编辑顺序有关系的。</p><blockquote><p>While nested locations are allowed by the configuration file parser, their use is discouraged and may produce unexpected results.</p></blockquote><p>实际上 nginx 的配置文件解析程序是允许 location 嵌套定义的（ location / { location /uri/ {} } ）。但是我们平时却很少看见这样的配置，那是因为 nginx 官方并不建议大家这么做，因为这样会导致很多意想不到的后果。</p><blockquote><p>The prefix “@” specifies a named location. Such locations are not used during normal processing of requests, they are intended only to process internally redirected requests (see error_page ,try_files ).</p></blockquote><p>文章开始说了location 的语法中，可以有“= ”，“^~ ”，“~ ”和“~* ”前缀，或者干脆没有任何前缀，还有“@ ”前缀，但是后面的分析我们始终没有谈到“@ ”前缀。文章最后点内容，介绍了“＠”的用途：“@ ”是用来定义“Named Location ”的（你可以理解为独立于“普通location （location using literal strings ）”和“正则location （location using regular expressions ）”之外的第三种类型），这种“Named Location ”不是用来处理普通的HTTP 请求的，它是专门用来处理“内部重定向（internally redirected ）”请求的。注意：这里说的“内部重定向（internally redirected ）”或许说成“forward ”会好点，以为内internally redirected 是不需要跟浏览器交互的，纯粹是服务端的一个转发行为。</p><h3 id="location-实例练习"><a href="#location-实例练习" class="headerlink" title="location 实例练习"></a>location 实例练习</h3><p>Nginx 的语法形式是：<code>location [=|~|~*|^~|@] /uri/ { … }</code>，意思是可以以“ = ”或“ ~* ”或“ ~ ”或“ ^~ ”或“ @ ”符号为前缀，当然也可以没有前缀（因为 [A] 是表示可选的 A ； A|B 表示 A 和 B 选一个），紧接着是 /uri/ ，再接着是{…} 指令块，整个意思是对于满足这样条件的 /uri/ 适用指令块 {…} 的指令。</p><p>上述各种 location 可分两大类，分别是：“普通 location ”，官方英文说法是 location using   literal strings 和“正则 location ”，英文说法是 location using regular expressions 。其中“普通 location ”是以“ = ”或“ ^~ ”为前缀或者没有任何前缀的 /uri/ ；“正则 location ”是以“ ~ ”或“ ~* ”为前缀的 /uri/ 。<br>那么，当我们在一个 server 上下文编写了多个 location 的时候， Nginx 对于一个 HTTP 请求，是如何匹配到一个 location 做处理呢？用一句话简单概括 Nginx 的 location 匹配规则是：“正则 location ”让步 “普通 location”的严格精确匹配结果；但覆盖 “普通 location ”的最大前缀匹配结果。理解这句话，我想通过下面的实例来说明。</p><ul><li><strong>先普通 location ，再正则 location</strong><br>周边不少童鞋告诉我， nginx 是“先匹配正则 location 再匹配普通 location ”，其实这是一个误区， nginx 其实是“先匹配普通 location ，再匹配正则 location ”，但是普通 location 的匹配结果又分两种：一种是“严格精确匹配”，官方英文说法是“ exact match ”；另一种是“最大前缀匹配”，官方英文说法是“ Literal strings match the beginning portion of the query – the most specific match will be used. ”。我们做个实验：</li></ul><p>例题 1 ：假设 nginx 的配置如下</p><pre><code>server {       listen       9090;       server_name  localhost;       location / {           root   html;           index  index.html index.htm;           deny all;       }       location ~ \.html$ {           allow all;       }}</code></pre><p>附录 nginx 的目录结构是： nginx-&gt;html-&gt;index.html<br>上述配置的意思是： location / {… deny all;} 普通 location 以“ / ”开始的 URI 请求（注意任何 HTTP 请求都必然以“/ ”开始，所以“ / ”的意思是所有的请求都能被匹配上），都拒绝访问； location ~.html$ {allow all;} 正则 location以 .html 结尾的 URI 请求，都允许访问。</p><p>测试结果：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@web108 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># curl http://localhost:9090/</span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span><span class="token operator">&lt;</span>title<span class="token operator">></span>403 Forbidden<span class="token operator">&lt;</span>/title<span class="token operator">></span><span class="token operator">&lt;</span>/head<span class="token operator">></span><span class="token operator">&lt;</span>body bgcolor<span class="token operator">=</span>”white”<span class="token operator">></span><span class="token operator">&lt;</span>center<span class="token operator">></span><span class="token operator">&lt;</span>h1<span class="token operator">></span>403 Forbidden<span class="token operator">&lt;</span>/h1<span class="token operator">></span><span class="token operator">&lt;</span>/center<span class="token operator">></span><span class="token operator">&lt;</span>hr<span class="token operator">></span><span class="token operator">&lt;</span>center<span class="token operator">></span>nginx/1.1.0<span class="token operator">&lt;</span>/center<span class="token operator">></span><span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">></span><span class="token punctuation">[</span>root@web108 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># curl http://localhost:9090/index.html</span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span><span class="token operator">&lt;</span>title<span class="token operator">></span>Welcome to nginx<span class="token operator">!</span><span class="token operator">&lt;</span>/title<span class="token operator">></span><span class="token operator">&lt;</span>/head<span class="token operator">></span><span class="token operator">&lt;</span>body bgcolor<span class="token operator">=</span>”white” text<span class="token operator">=</span>”black”<span class="token operator">></span><span class="token operator">&lt;</span>center<span class="token operator">></span><span class="token operator">&lt;</span>h1<span class="token operator">></span>Welcome to nginx<span class="token operator">!</span><span class="token operator">&lt;</span>/h1<span class="token operator">></span><span class="token operator">&lt;</span>/center<span class="token operator">></span><span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">></span><span class="token punctuation">[</span>root@web108 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># curl http://localhost:9090/index_notfound.html</span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span><span class="token operator">&lt;</span>title<span class="token operator">></span>404 Not Found<span class="token operator">&lt;</span>/title<span class="token operator">></span><span class="token operator">&lt;</span>/head<span class="token operator">></span><span class="token operator">&lt;</span>body bgcolor<span class="token operator">=</span>”white”<span class="token operator">></span><span class="token operator">&lt;</span>center<span class="token operator">></span><span class="token operator">&lt;</span>h1<span class="token operator">></span>404 Not Found<span class="token operator">&lt;</span>/h1<span class="token operator">></span><span class="token operator">&lt;</span>/center<span class="token operator">></span><span class="token operator">&lt;</span>hr<span class="token operator">></span><span class="token operator">&lt;</span>center<span class="token operator">></span>nginx/1.1.0<span class="token operator">&lt;</span>/center<span class="token operator">></span><span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">></span></code></pre><p>测试结果如下：</p><table><thead><tr><th style="text-align:left">URI请求</th><th style="text-align:center">HTTP响应</th></tr></thead><tbody><tr><td style="text-align:left">curl <a href="http://localhost:9090/" target="_blank" rel="noopener">http://localhost:9090/</a></td><td style="text-align:center">403 Forbidden</td></tr><tr><td style="text-align:left">curl <a href="http://localhost:9090/index.html" target="_blank" rel="noopener">http://localhost:9090/index.html</a></td><td style="text-align:center">Welcome to nginx!</td></tr><tr><td style="text-align:left">curl <a href="http://localhost:9090/index_notfound.html" target="_blank" rel="noopener">http://localhost:9090/index_notfound.html</a></td><td style="text-align:center">404 Not Found</td></tr></tbody></table><p><code>curl http://localhost:9090/</code> 的结果是“ 403 Forbidden ”，说明被匹配到“ location / {..deny all;} ”了，原因很简单HTTP 请求 GET / 被“严格精确”匹配到了普通 location / {} ，则会停止搜索正则 location ；</p><p><code>curl http://localhost:9090/index.html</code> 结果是“ Welcome to nginx! ”，说明没有被“ location / {…deny all;} ”匹配，否则会 403 Forbidden ，但 /index.html 的确也是以“ / ”开头的，只不过此时的普通 location / 的匹配结果是“最大前缀”匹配，所以 Nginx 会继续搜索正则 location ， location ~ .html$ 表达了以 .html 结尾的都 allow all; 于是接着就访问到了实际存在的 index.html 页面。</p><p><code>curl http://localhost:9090/index_notfound.html</code>   同样的道理先匹配 location / {} ，但属于“普通 location 的最大前缀匹配”，于是后面被“正则 location ” location ~ .html$ {} 覆盖了，最终 allow all ； 但的确目录下不存在index_notfound.html 页面，于是 404 Not Found 。</p><p>如果此时我们访问 <a href="http://localhost:9090/index.txt" target="_blank" rel="noopener">http://localhost:9090/index.txt</a> 会是什么结果呢？显然是 deny all ；因为先匹配上了 location / {..deny all;} 尽管属于“普通 location ”的最大前缀匹配结果，继续搜索正则 location ，但是 /index.txt 不是以 .html结尾的，正则 location 失败，最终采纳普通 location 的最大前缀匹配结果，于是 deny all 了。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@web108 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># curl http://localhost:9090/index.txt</span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span><span class="token operator">&lt;</span>title<span class="token operator">></span>403 Forbidden<span class="token operator">&lt;</span>/title<span class="token operator">></span><span class="token operator">&lt;</span>/head<span class="token operator">></span><span class="token operator">&lt;</span>body bgcolor<span class="token operator">=</span>”white”<span class="token operator">></span><span class="token operator">&lt;</span>center<span class="token operator">></span><span class="token operator">&lt;</span>h1<span class="token operator">></span>403 Forbidden<span class="token operator">&lt;</span>/h1<span class="token operator">></span><span class="token operator">&lt;</span>/center<span class="token operator">></span><span class="token operator">&lt;</span>hr<span class="token operator">></span><span class="token operator">&lt;</span>center<span class="token operator">></span>nginx/1.1.0<span class="token operator">&lt;</span>/center<span class="token operator">></span><span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">></span></code></pre><ul><li><strong>普通 location 的“隐式”严格匹配</strong></li></ul><p>例题 2 ：我们在例题 1 的基础上增加精确配置</p><pre><code>server {       listen       9090;       server_name  localhost;       location /exact/match.html {           allow all;       }       location / {           root   html;           index  index.html index.htm;           deny all;       }       location ~ \.html$ {           allow all;       }}</code></pre><p>测试请求：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@web108 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># curl http://localhost:9090/exact/match.html</span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span><span class="token operator">&lt;</span>title<span class="token operator">></span>404 Not Found<span class="token operator">&lt;</span>/title<span class="token operator">></span><span class="token operator">&lt;</span>/head<span class="token operator">></span><span class="token operator">&lt;</span>body bgcolor<span class="token operator">=</span>”white”<span class="token operator">></span><span class="token operator">&lt;</span>center<span class="token operator">></span><span class="token operator">&lt;</span>h1<span class="token operator">></span>404 Not Found<span class="token operator">&lt;</span>/h1<span class="token operator">></span><span class="token operator">&lt;</span>/center<span class="token operator">></span><span class="token operator">&lt;</span>hr<span class="token operator">></span><span class="token operator">&lt;</span>center<span class="token operator">></span>nginx/1.1.0<span class="token operator">&lt;</span>/center<span class="token operator">></span><span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">></span></code></pre><p>结果进一步验证了“普通 location ”的“严格精确”匹配会终止对正则 location 的搜索。这里我们小结下“普通 location”与“正则 location ”的匹配规则：先匹配普通 location ，再匹配正则 location ，但是如果普通 location 的匹配结果恰好是“严格精确（ exact match ）”的，则 nginx 不再尝试后面的正则 location ；如果普通 location 的匹配结果是“最大前缀”，则正则 location 的匹配覆盖普通 location 的匹配。也就是前面说的“正则 location 让步普通location 的严格精确匹配结果，但覆盖普通 location 的最大前缀匹配结果”。</p><ul><li><strong>普通 location 的“显式”严格匹配和“ ^~ ” 前缀</strong></li></ul><p>上面我们演示的普通 location 都是不加任何前缀的，其实普通 location 也可以加前缀：“ ^~ ”和“ = ”。其中“ ^~”的意思是“非正则，不需要继续正则匹配”，也就是通常我们的普通 location ，还会继续搜索正则 location （恰好严格精确匹配除外），但是 nginx 很人性化允许配置人员告诉 nginx 某条普通 location ，无论最大前缀匹配，还是严格精确匹配都终止继续搜索正则 location ；而“ = ”则表达的是普通 location 不允许“最大前缀”匹配结果，必须严格等于，严格精确匹配。</p><p>例题 3 ：“ ^~ ”前缀的使用</p><pre class=" language-bash"><code class="language-bash">server <span class="token punctuation">{</span>       listen       9090<span class="token punctuation">;</span>       server_name  localhost<span class="token punctuation">;</span>       location /exact/match.html <span class="token punctuation">{</span>           allow all<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       location ^~ / <span class="token punctuation">{</span>           root   html<span class="token punctuation">;</span>           index  index.html index.htm<span class="token punctuation">;</span>           deny all<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       location ~ \.html$ <span class="token punctuation">{</span>           allow all<span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>把例题 2 中的 location / {} 修改成 location ^~ / {} ，再看看测试结果：</p><table><thead><tr><th>URL请求</th><th style="text-align:center">修改前</th><th style="text-align:center">修改后</th></tr></thead><tbody><tr><td>curl <a href="http://localhost:9090/" target="_blank" rel="noopener">http://localhost:9090/</a></td><td style="text-align:center">403 Forbidden</td><td style="text-align:center">403 Forbidden</td></tr><tr><td>curl <a href="http://localhost:9090/index.html" target="_blank" rel="noopener">http://localhost:9090/index.html</a></td><td style="text-align:center">Welcome to nginx!</td><td style="text-align:center">403 Forbidden</td></tr><tr><td>curl <a href="http://localhost:9090/index_notfound.html" target="_blank" rel="noopener">http://localhost:9090/index_notfound.html</a></td><td style="text-align:center">404 Not Found</td><td style="text-align:center">403 Forbidden</td></tr><tr><td>curl <a href="http://localhost:9090/exact/match.html" target="_blank" rel="noopener">http://localhost:9090/exact/match.html</a></td><td style="text-align:center">404 Not Found</td><td style="text-align:center">404 Not Found</td></tr></tbody></table><p>除了 GET /exact/match.html 是 404 Not Found ，其余都是 403 Forbidden ，原因很简单所有请求都是以“ / ”开头，所以所有请求都能匹配上“ / ”普通 location ，但普通 location 的匹配原则是“最大前缀”，所以只有/exact/match.html 匹配到 location /exact/match.html {allow all;} ，其余都 location ^~ / {deny all;} 并终止正则搜索。</p><p>例题 4 ：“ = ”前缀的使用</p><pre class=" language-bash"><code class="language-bash">server <span class="token punctuation">{</span>       listen       9090<span class="token punctuation">;</span>       server_name  localhost<span class="token punctuation">;</span>       location /exact/match.html <span class="token punctuation">{</span>           allow all<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       location <span class="token operator">=</span> / <span class="token punctuation">{</span>           root   html<span class="token punctuation">;</span>           index  index.html index.htm<span class="token punctuation">;</span>           deny all<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       location ~ \.html$ <span class="token punctuation">{</span>           allow all<span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>例题 4 相对例题 2 把 location / {} 修改成了 location = / {} ，再次测试结果：</p><table><thead><tr><th>URL请求</th><th style="text-align:center">修改前</th><th style="text-align:center">修改后</th></tr></thead><tbody><tr><td>curl <a href="http://localhost:9090/" target="_blank" rel="noopener">http://localhost:9090/</a></td><td style="text-align:center">403 Forbidden</td><td style="text-align:center">403 Forbidden</td></tr><tr><td>curl <a href="http://localhost:9090/index.html" target="_blank" rel="noopener">http://localhost:9090/index.html</a></td><td style="text-align:center">Welcome to nginx!</td><td style="text-align:center">Welcome to nginx!</td></tr><tr><td>curl <a href="http://localhost:9090/index_notfound.html" target="_blank" rel="noopener">http://localhost:9090/index_notfound.html</a></td><td style="text-align:center">404 Not Found</td><td style="text-align:center">404 Not Found</td></tr><tr><td>curl <a href="http://localhost:9090/exact/match.html" target="_blank" rel="noopener">http://localhost:9090/exact/match.html</a></td><td style="text-align:center">404 Not Found</td><td style="text-align:center">404 Not Found</td></tr><tr><td>curl <a href="http://localhost:9090/test.jsp" target="_blank" rel="noopener">http://localhost:9090/test.jsp</a></td><td style="text-align:center">403 Forbidden</td><td style="text-align:center">404 Not Found</td></tr></tbody></table><p>最能说明问题的测试是 GET /test.jsp ，实际上 /test.jsp 没有匹配正则 location （ location ~.html$ ），也没有匹配 location = / {} ，如果按照 location / {} 的话，会“最大前缀”匹配到普通 location / {} ，结果是 deny all 。</p><ul><li><strong>正则 location 与编辑顺序</strong><br>location 的指令与编辑顺序无关，这句话不全对。对于普通 location 指令，匹配规则是：最大前缀匹配（与顺序无关），如果恰好是严格精确匹配结果或者加有前缀“ ^~ ”或“ = ”（符号“ = ”只能严格匹配，不能前缀匹配），则停止搜索正则 location ；但对于正则 location 的匹配规则是：按编辑顺序逐个匹配（与顺序有关），只要匹配上，就立即停止后面的搜索。</li></ul><pre class=" language-bash"><code class="language-bash">配置 3.1server <span class="token punctuation">{</span>       listen       9090<span class="token punctuation">;</span>       server_name  localhost<span class="token punctuation">;</span>       location ~ \.html$ <span class="token punctuation">{</span>           allow all<span class="token punctuation">;</span>        <span class="token punctuation">}</span>         location ~ ^/prefix/.*\.html$ <span class="token punctuation">{</span>           deny all<span class="token punctuation">;</span>         <span class="token punctuation">}</span>  <span class="token punctuation">}</span>配置 3.2server <span class="token punctuation">{</span>       listen       9090<span class="token punctuation">;</span>       server_name  localhost<span class="token punctuation">;</span>            location ~ ^/prefix/.*\.html$ <span class="token punctuation">{</span>           deny all<span class="token punctuation">;</span>         <span class="token punctuation">}</span>                   location ~ \.html$ <span class="token punctuation">{</span>           allow all<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>测试结果：</p><table><thead><tr><th>URL请求</th><th style="text-align:center">配置3.1</th><th style="text-align:center">配置3.2</th></tr></thead><tbody><tr><td>curl <a href="http://localhost:9090/regextest.html" target="_blank" rel="noopener">http://localhost:9090/regextest.html</a></td><td style="text-align:center">404 Not Found</td><td style="text-align:center">404 Not Found</td></tr><tr><td>curl <a href="http://localhost:9090/prefix/regextest.html" target="_blank" rel="noopener">http://localhost:9090/prefix/regextest.html</a></td><td style="text-align:center">404 Not Found</td><td style="text-align:center">403 Forbidden</td></tr></tbody></table><p>解释：<br><code>Location ~ ^/prefix/.*\.html$ {deny all;}</code> 表示正则 location 对于以 /prefix/ 开头， .html 结尾的所有 URI 请求，都拒绝访问；   <code>location ~\.html${allow all;}</code> 表示正则 location 对于以 .html 结尾的 URI 请求，都允许访问。 实际上，prefix 的是 ~.html$ 的子集。</p><p>在“配置 3.1 ”下，两个请求都匹配上 <code>location ~\.html$ {allow all;}</code> ，并且停止后面的搜索，于是都允许访问， 404 Not Found ；在“配置 3.2 ”下， /regextest.html 无法匹配 prefix ，于是继续搜索 ~.html$ ，允许访问，于是 404 Not Found ；然而 /prefix/regextest.html 匹配到 prefix ，于是 deny all ， 403 Forbidden 。</p><pre><code>配置 3.3server {       listen       9090;       server_name  localhost;        location  /prefix/ {               deny all;         }                  location  /prefix/mid/ {               allow all;        }  }配置 3.4server {       listen       9090;       server_name  localhost;           location  /prefix/mid/ {               allow all;        }          location  /prefix/ {               deny all;         }  }</code></pre><p>测试结果：</p><table><thead><tr><th>URL请求</th><th style="text-align:center">配置3.3</th><th style="text-align:center">配置3.4</th></tr></thead><tbody><tr><td>curl <a href="http://localhost:9090/prefix/t.html" target="_blank" rel="noopener">http://localhost:9090/prefix/t.html</a></td><td style="text-align:center">403 Forbidden</td><td style="text-align:center">403 Forbidden</td></tr><tr><td>curl <a href="http://localhost:9090/prefix/mid/t.html" target="_blank" rel="noopener">http://localhost:9090/prefix/mid/t.html</a></td><td style="text-align:center">404 Not Found</td><td style="text-align:center">404 Not Found</td></tr></tbody></table><p>测试结果表明：普通 location 的匹配规则是“最大前缀”匹配，而且与编辑顺序无关。</p><ul><li><p><strong>“@” 前缀 Named Location 使用</strong><br>REFER:  <a href="http://wiki.nginx.org/HttpCoreModule#error_page" target="_blank" rel="noopener">http://wiki.nginx.org/HttpCoreModule#error_page</a><br>假设配置如下：</p><pre class=" language-bash"><code class="language-bash">server <span class="token punctuation">{</span>     listen       9090<span class="token punctuation">;</span>     server_name  localhost<span class="token punctuation">;</span>     location  / <span class="token punctuation">{</span>         root   html<span class="token punctuation">;</span>         index  index.html index.htm<span class="token punctuation">;</span>         allow all<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">#error_page 404 http://www.baidu.com # 直接这样是不允许的</span>     error_page 404 <span class="token operator">=</span> @fallback<span class="token punctuation">;</span>     location @fallback <span class="token punctuation">{</span>         proxy_pass http://www.baidu.com<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述配置文件的意思是：如果请求的 URI 存在，则本 nginx 返回对应的页面；如果不存在，则把请求代理到baidu.com 上去做个弥补（注： nginx 当发现 URI 对应的页面不存在， HTTP_StatusCode 会是 404 ，此时error_page 404 指令能捕获它）。</p></li></ul><p>测试一：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@web108 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># curl http://localhost:9090/nofound.html -i</span>HTTP/1.1 302 FoundServer: nginx/1.1.0Date: Sat, 06 Aug 2011 08:17:21 GMTContent-Type: text/html<span class="token punctuation">;</span> charset<span class="token operator">=</span>iso-8859-1Location: http://localhost:9090/search/error.htmlConnection: keep-aliveCache-Control: max-age<span class="token operator">=</span>86400Expires: Sun, 07 Aug 2011 08:17:21 GMTContent-Length: 222<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE HTML PUBLIC “-//IETF//DTD HTML 2.0//EN”<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span><span class="token operator">&lt;</span>title<span class="token operator">></span>302 Found<span class="token operator">&lt;</span>/title<span class="token operator">></span><span class="token operator">&lt;</span>/head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>h1<span class="token operator">></span>Found<span class="token operator">&lt;</span>/h1<span class="token operator">></span><span class="token operator">&lt;</span>p<span class="token operator">></span>The document has moved <span class="token operator">&lt;</span>a href<span class="token operator">=</span>”http://www.baidu.com/search/error.html”<span class="token operator">></span>here<span class="token operator">&lt;</span>/a<span class="token operator">></span>.<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">></span></code></pre><p>当我们 GET /nofound.html 发送给本 nginx ， nginx 找不到对应的页面，于是 error_page 404 = @fallback ，请求被代理到 <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> ，于是 nginx 给 <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> 发送了 GET /nofound.html ，但/nofound.html 页面在百度也不存在，百度 302 跳转到错误页。<br>直接访问 <a href="http://www.baidu.com/nofound.html" target="_blank" rel="noopener">http://www.baidu.com/nofound.html</a> 结果：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@web108 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># curl http://www.baidu.com/nofound.html -i</span>HTTP/1.1 302 FoundDate: Sat, 06 Aug 2011 08:20:05 GMTServer: ApacheLocation: http://www.baidu.com/search/error.htmlCache-Control: max-age<span class="token operator">=</span>86400Expires: Sun, 07 Aug 2011 08:20:05 GMTContent-Length: 222Connection: Keep-AliveContent-Type: text/html<span class="token punctuation">;</span> charset<span class="token operator">=</span>iso-8859-1<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE HTML PUBLIC “-//IETF//DTD HTML 2.0//EN”<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span><span class="token operator">&lt;</span>title<span class="token operator">></span>302 Found<span class="token operator">&lt;</span>/title<span class="token operator">></span><span class="token operator">&lt;</span>/head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>h1<span class="token operator">></span>Found<span class="token operator">&lt;</span>/h1<span class="token operator">></span><span class="token operator">&lt;</span>p<span class="token operator">></span>The document has moved <span class="token operator">&lt;</span>a href<span class="token operator">=</span>”http://www.baidu.com/search/error.html”<span class="token operator">></span>here<span class="token operator">&lt;</span>/a<span class="token operator">></span>.<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">></span></code></pre><p>测试二：访问一个 nginx 不存在，但 baidu 存在的页面</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@web108 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># curl http://www.baidu.com/duty/ -i</span>HTTP/1.1 200 OKDate: Sat, 06 Aug 2011 08:21:56 GMTServer: ApacheP3P: CP<span class="token operator">=</span>” OTI DSP COR IVA OUR IND COM ”P3P: CP<span class="token operator">=</span>” OTI DSP COR IVA OUR IND COM ”Set-Cookie: BAIDUID<span class="token operator">=</span>5C5D2B2FD083737A0C88CA7075A6601A:FG<span class="token operator">=</span>1<span class="token punctuation">;</span> expires<span class="token operator">=</span>Sun, 05-Aug-12 08:21:56 GMT<span class="token punctuation">;</span> max-age<span class="token operator">=</span>31536000<span class="token punctuation">;</span> path<span class="token operator">=</span>/<span class="token punctuation">;</span> domain<span class="token operator">=</span>.baidu.com<span class="token punctuation">;</span> version<span class="token operator">=</span>1Set-Cookie: BAIDUID<span class="token operator">=</span>5C5D2B2FD083737A2337F78F909CCB90:FG<span class="token operator">=</span>1<span class="token punctuation">;</span> expires<span class="token operator">=</span>Sun, 05-Aug-12 08:21:56 GMT<span class="token punctuation">;</span> max-age<span class="token operator">=</span>31536000<span class="token punctuation">;</span> path<span class="token operator">=</span>/<span class="token punctuation">;</span> domain<span class="token operator">=</span>.baidu.com<span class="token punctuation">;</span> version<span class="token operator">=</span>1Last-Modified: Wed, 05 Jan 2011 06:44:53 GMTETag: “d66-49913b8efe340″Accept-Ranges: bytesContent-Length: 3430Cache-Control: max-age<span class="token operator">=</span>86400Expires: Sun, 07 Aug 2011 08:21:56 GMTVary: Accept-Encoding,User-AgentConnection: Keep-AliveContent-Type: text/html<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”“http://www.w3.org/TR/html4/loose.dtd”<span class="token operator">></span>。。。。<span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">></span></code></pre><p>显示，的确百度这个页面是存在的。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@web108 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># curl http://localhost:9090/duty/ -i</span>HTTP/1.1 200 OKServer: nginx/1.1.0Date: Sat, 06 Aug 2011 08:23:23 GMTContent-Type: text/htmlConnection: keep-aliveP3P: CP<span class="token operator">=</span>” OTI DSP COR IVA OUR IND COM ”P3P: CP<span class="token operator">=</span>” OTI DSP COR IVA OUR IND COM ”Set-Cookie: BAIDUID<span class="token operator">=</span>8FEF0A3A2C31D277DCB4CC5F80B7F457:FG<span class="token operator">=</span>1<span class="token punctuation">;</span> expires<span class="token operator">=</span>Sun, 05-Aug-12 08:23:23 GMT<span class="token punctuation">;</span> max-age<span class="token operator">=</span>31536000<span class="token punctuation">;</span> path<span class="token operator">=</span>/<span class="token punctuation">;</span> domain<span class="token operator">=</span>.baidu.com<span class="token punctuation">;</span> version<span class="token operator">=</span>1Set-Cookie: BAIDUID<span class="token operator">=</span>8FEF0A3A2C31D277B1F87691AFFD7440:FG<span class="token operator">=</span>1<span class="token punctuation">;</span> expires<span class="token operator">=</span>Sun, 05-Aug-12 08:23:23 GMT<span class="token punctuation">;</span> max-age<span class="token operator">=</span>31536000<span class="token punctuation">;</span> path<span class="token operator">=</span>/<span class="token punctuation">;</span> domain<span class="token operator">=</span>.baidu.com<span class="token punctuation">;</span> version<span class="token operator">=</span>1Last-Modified: Wed, 05 Jan 2011 06:44:53 GMTETag: “d66-49913b8efe340″Accept-Ranges: bytesContent-Length: 3430Cache-Control: max-age<span class="token operator">=</span>86400Expires: Sun, 07 Aug 2011 08:23:23 GMTVary: Accept-Encoding,User-Agent<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”“http://www.w3.org/TR/html4/loose.dtd”<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span>。。。<span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">></span></code></pre><p>当 <code>curl http://localhost:9090/duty/ -i</code> 时， nginx 没找到对应的页面，于是 error_page = @fallback ，把请求代理到 baidu.com 。注意这里的 error_page = @fallback 不是靠重定向实现的，而是所说的“ internally redirected （forward ）”。</p><h3 id="proxy-pass-URL-末尾加与不加-（斜线）的区别"><a href="#proxy-pass-URL-末尾加与不加-（斜线）的区别" class="headerlink" title="proxy_pass URL 末尾加与不加/（斜线）的区别"></a>proxy_pass URL 末尾加与不加/（斜线）的区别</h3><blockquote><p>Proxy_pass末尾带”/”和不带是有区别的：<br>不带斜杠转发的是除hostname以外的部分，包括目录。可以使用正则表达式匹配location，且任意正则匹配成功后，转发的都是完整目录路径。<br>带斜杠转发的是除hostname及目录外的所有部分。不能使用正则表达式匹配location块，只能使用完整路径名准确匹配。</p></blockquote><pre><code>配置1location /tobaidu {    proxy_pass http://127.0.0.1:8087;}</code></pre><p>测试结果：</p><table><thead><tr><th>请求URL</th><th>请求结果</th></tr></thead><tbody><tr><td>curl <a href="http://127.0.0.1/tobaidu" target="_blank" rel="noopener">http://127.0.0.1/tobaidu</a></td><td><a href="http://127.0.0.1:8087/tobaidu" target="_blank" rel="noopener">http://127.0.0.1:8087/tobaidu</a></td></tr><tr><td>curl <a href="http://127.0.0.1/tobaidu/" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/</a></td><td><a href="http://127.0.0.1:8087/tobaidu/" target="_blank" rel="noopener">http://127.0.0.1:8087/tobaidu/</a></td></tr><tr><td>curl <a href="http://127.0.0.1/tobaidu/xxxx" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/xxxx</a></td><td><a href="http://127.0.0.1:8087/tobaidu/xxxx" target="_blank" rel="noopener">http://127.0.0.1:8087/tobaidu/xxxx</a></td></tr></tbody></table><pre><code>配置2location /tobaidu {    proxy_pass http://127.0.0.1:8087/define;}</code></pre><p>测试结果：</p><table><thead><tr><th>请求URL</th><th>请求结果</th></tr></thead><tbody><tr><td>curl <a href="http://127.0.0.1/tobaidu" target="_blank" rel="noopener">http://127.0.0.1/tobaidu</a></td><td><a href="http://127.0.0.1:8087/define" target="_blank" rel="noopener">http://127.0.0.1:8087/define</a></td></tr><tr><td>curl <a href="http://127.0.0.1/tobaidu/" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/</a></td><td><a href="http://127.0.0.1:8087/define/" target="_blank" rel="noopener">http://127.0.0.1:8087/define/</a></td></tr><tr><td>curl <a href="http://127.0.0.1/tobaidu/xxxx" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/xxxx</a></td><td><a href="http://127.0.0.1:8087/define/xxxx" target="_blank" rel="noopener">http://127.0.0.1:8087/define/xxxx</a></td></tr></tbody></table><pre><code>配置3location /tobaidu/ {    proxy_pass http://127.0.0.1:8087;}</code></pre><p>测试结果：</p><table><thead><tr><th>请求URL</th><th>请求结果</th></tr></thead><tbody><tr><td>curl <a href="http://127.0.0.1/tobaidu" target="_blank" rel="noopener">http://127.0.0.1/tobaidu</a></td><td>重定向到<a href="http://127.0.0.1/tobaidu/" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/</a></td></tr><tr><td>curl <a href="http://127.0.0.1/tobaidu/" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/</a></td><td><a href="http://127.0.0.1:8087/tobaidu/" target="_blank" rel="noopener">http://127.0.0.1:8087/tobaidu/</a></td></tr><tr><td>curl <a href="http://127.0.0.1/tobaidu/xxxx" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/xxxx</a></td><td><a href="http://127.0.0.1:8087/tobaidu/xxxx" target="_blank" rel="noopener">http://127.0.0.1:8087/tobaidu/xxxx</a></td></tr></tbody></table><pre><code>配置4location /tobaidu/ {    proxy_pass http://127.0.0.1:8087/define;}</code></pre><p>测试结果：</p><table><thead><tr><th>请求URL</th><th>请求结果</th></tr></thead><tbody><tr><td>curl <a href="http://127.0.0.1/tobaidu" target="_blank" rel="noopener">http://127.0.0.1/tobaidu</a></td><td>重定向到<a href="http://127.0.0.1/tobaidu/" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/</a></td></tr><tr><td>curl <a href="http://127.0.0.1/tobaidu/" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/</a></td><td><a href="http://127.0.0.1:8087/define" target="_blank" rel="noopener">http://127.0.0.1:8087/define</a></td></tr><tr><td>curl <a href="http://127.0.0.1/tobaidu/xxxx" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/xxxx</a></td><td><a href="http://127.0.0.1:8087/define/xxxx" target="_blank" rel="noopener">http://127.0.0.1:8087/define/xxxx</a></td></tr></tbody></table><pre><code>配置5location /tobaidu {    proxy_pass http://127.0.0.1:8087/;}</code></pre><p>测试结果：</p><table><thead><tr><th>请求URL</th><th>请求结果</th></tr></thead><tbody><tr><td>curl <a href="http://127.0.0.1/tobaidu" target="_blank" rel="noopener">http://127.0.0.1/tobaidu</a></td><td><a href="http://127.0.0.1:8087/" target="_blank" rel="noopener">http://127.0.0.1:8087/</a></td></tr><tr><td>curl <a href="http://127.0.0.1/tobaidu/" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/</a></td><td><a href="http://127.0.0.1:8087//" target="_blank" rel="noopener">http://127.0.0.1:8087//</a></td></tr><tr><td>curl <a href="http://127.0.0.1/tobaidu/xxxx" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/xxxx</a></td><td><a href="http://127.0.0.1:8087//xxxx" target="_blank" rel="noopener">http://127.0.0.1:8087//xxxx</a></td></tr></tbody></table><pre><code>配置6location /tobaidu {    proxy_pass http://127.0.0.1:8087/define/;}</code></pre><p>测试结果：</p><table><thead><tr><th>请求URL</th><th>请求结果</th></tr></thead><tbody><tr><td>curl <a href="http://127.0.0.1/tobaidu" target="_blank" rel="noopener">http://127.0.0.1/tobaidu</a></td><td><a href="http://127.0.0.1:8087/define/" target="_blank" rel="noopener">http://127.0.0.1:8087/define/</a></td></tr><tr><td>curl <a href="http://127.0.0.1/tobaidu/" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/</a></td><td><a href="http://127.0.0.1:8087/define//" target="_blank" rel="noopener">http://127.0.0.1:8087/define//</a></td></tr><tr><td>curl <a href="http://127.0.0.1/tobaidu/xxxx" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/xxxx</a></td><td><a href="http://127.0.0.1:8087/define//xxxx" target="_blank" rel="noopener">http://127.0.0.1:8087/define//xxxx</a></td></tr></tbody></table><pre><code>配置7location /tobaidu/ {    proxy_pass http://127.0.0.1:8087/;}</code></pre><p>测试结果：</p><table><thead><tr><th>请求URL</th><th>请求结果</th></tr></thead><tbody><tr><td>curl <a href="http://127.0.0.1/tobaidu" target="_blank" rel="noopener">http://127.0.0.1/tobaidu</a></td><td>重定向到<a href="http://127.0.0.1/tobaidu/" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/</a></td></tr><tr><td>curl <a href="http://127.0.0.1/tobaidu/" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/</a></td><td><a href="http://127.0.0.1:8087/" target="_blank" rel="noopener">http://127.0.0.1:8087/</a></td></tr><tr><td>curl <a href="http://127.0.0.1/tobaidu/xxxx" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/xxxx</a></td><td><a href="http://127.0.0.1:8087/xxxx" target="_blank" rel="noopener">http://127.0.0.1:8087/xxxx</a></td></tr></tbody></table><pre><code>配置8location /tobaidu/ {    proxy_pass http://127.0.0.1:8087/define/;}</code></pre><p>测试结果：</p><table><thead><tr><th>请求URL</th><th>请求结果</th></tr></thead><tbody><tr><td>curl <a href="http://127.0.0.1/tobaidu" target="_blank" rel="noopener">http://127.0.0.1/tobaidu</a></td><td>重定向到<a href="http://127.0.0.1/tobaidu/" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/</a></td></tr><tr><td>curl <a href="http://127.0.0.1/tobaidu/" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/</a></td><td><a href="http://127.0.0.1:8087/define/" target="_blank" rel="noopener">http://127.0.0.1:8087/define/</a></td></tr><tr><td>curl <a href="http://127.0.0.1/tobaidu/xxxx" target="_blank" rel="noopener">http://127.0.0.1/tobaidu/xxxx</a></td><td><a href="http://127.0.0.1:8087/define/xxxx" target="_blank" rel="noopener">http://127.0.0.1:8087/define/xxxx</a></td></tr></tbody></table><p><strong>结论</strong><br><em>URL符合 <code>protocol://ip:port</code> 同时结尾不加/,则nginx会代理匹配路径部分,否则不代理匹配路径,同时自动添加不匹配路径”部分”,比如/tobaidu/xxxx的/xxxx部分</em></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP请求头响应头字段详解</title>
      <link href="/2017/12/26/http-header/"/>
      <url>/2017/12/26/http-header/</url>
      
        <content type="html"><![CDATA[<p>HTTP消息头是指，在超文本传输协议（ Hypertext Transfer Protocol ，HTTP）的请求和响应消息中，协议头部分的那些组件。HTTP消息头用来准确描述正在获取的资源、服务器或者客户端的行为，定义了HTTP事务中的具体操作参数。</p><h3 id="关于HTTP消息头"><a href="#关于HTTP消息头" class="headerlink" title="关于HTTP消息头"></a>关于HTTP消息头</h3><p>HTTP消息头是在<code>客户端请求（Request）</code> 或<code>服务器响应（Response）</code> 时传递的，为请求或响应的第一行，HTTP消息体（请求或响应的内容）是其后传输。HTTP消息头，以明文的字符串格式传送，是以冒号分隔的键/值对，如：Accept-Charset: utf-8，每一个消息头最后以回车符(CR)和换行符(LF)结尾。HTTP消息头结束后，会用一个空白的字段来标识，这样就会出现两个连续的CR-LF。<br>HTTP消息头支持自定义， 自定义的专用消息头一般会添加’X-‘前缀。</p><h3 id="常用标准请求头字段"><a href="#常用标准请求头字段" class="headerlink" title="常用标准请求头字段"></a>常用标准请求头字段</h3><p><strong>Accept 设置接受的内容类型</strong></p><pre><code>Accept: text/plain</code></pre><p><strong>Accept-Charset 设置接受的字符编码</strong></p><pre><code>Accept-Charset: utf-8</code></pre><p><strong>Accept-Encoding 设置接受的编码格式</strong></p><pre><code>Accept-Encoding: gzip, deflate</code></pre><p><strong>Accept-Datetime 设置接受的版本时间</strong></p><pre><code>Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT</code></pre><p><strong>Accept-Language 设置接受的语言</strong></p><pre><code>Accept-Language: en-US</code></pre><p><strong>Authorization 设置HTTP身份验证的凭证</strong></p><pre><code>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</code></pre><p><strong>Cache-Control 设置请求响应链上所有的缓存机制必须遵守的指令</strong></p><pre><code>Cache-Control: no-cache</code></pre><p><strong>Connection 设置当前连接和hop-by-hop协议请求字段列表的控制选项</strong></p><pre><code>Connection: keep-aliveConnection: Upgrade</code></pre><p><strong>Content-Length 设置请求体的字节长度</strong></p><pre><code>Content-Length: 348</code></pre><p><strong>Content-MD5 设置基于MD5算法对请求体内容进行Base64二进制编码</strong></p><pre><code>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</code></pre><p><strong>Content-Type 设置请求体的MIME类型（适用POST和PUT请求）</strong></p><pre><code>Content-Type: application/x-www-form-urlencoded</code></pre><p><strong>Cookie 设置服务器使用Set-Cookie发送的http cookie</strong></p><pre><code>Cookie: $Version=1; Skin=new;</code></pre><p><strong>Date 设置消息发送的日期和时间</strong></p><pre><code>Date: Tue, 15 Nov 1994 08:12:31 GMT</code></pre><p><strong>Expect 标识客户端需要的特殊浏览器行为</strong></p><pre><code>Expect: 100-continue</code></pre><p><strong>Forwarded 披露客户端通过http代理连接web服务的源信息</strong></p><pre><code>Forwarded: for=192.0.2.60;proto=http;by=203.0.113.43Forwarded: for=192.0.2.43, for=198.51.100.17</code></pre><p><strong>From 设置发送请求的用户的email地址</strong></p><pre><code>From: user@example.com</code></pre><p><strong>Host 设置服务器域名和TCP端口号，如果使用的是服务请求标准端口号，端口号可以省略</strong></p><pre><code>Host: en.wikipedia.org:8080Host: en.wikipedia.org</code></pre><p><strong>If-Match 设置客户端的ETag,当时客户端ETag和服务器生成的ETag一致才执行，适用于更新自从上次更新之后没有改变的资源</strong></p><pre><code>If-Match: &quot;737060cd8c284d8af7ad3082f209582d</code></pre><p><strong>If-Modified-Since 设置更新时间，从更新时间到服务端接受请求这段时间内如果资源没有改变，允许服务端返回304 Not Modified</strong></p><pre><code>If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</code></pre><p><strong>If-None-Match 设置客户端ETag，如果和服务端接受请求生成的ETage相同，允许服务端返回304 Not Modified</strong></p><pre><code>If-None-Match: &quot;737060cd8c284d8af7ad3082f209582d&quot;</code></pre><p><strong>If-Range 设置客户端ETag，如果和服务端接受请求生成的ETage相同，返回缺失的实体部分；否则返回整个新的实体</strong></p><pre><code>If-Range: &quot;737060cd8c284d8af7ad3082f209582d&quot;</code></pre><p><strong>If-Unmodified-Since 设置更新时间，只有从更新时间到服务端接受请求这段时间内实体没有改变，服务端才会发送响应</strong></p><pre><code>If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT</code></pre><p><strong>Max-Forwards 限制代理或网关转发消息的次数</strong></p><pre><code>Max-Forwards: 10</code></pre><p><strong>Origin 标识跨域资源请求（请求服务端设置Access-Control-Allow-Origin响应字段）</strong></p><pre><code>Origin: http://www.example-social-network.com</code></pre><p><strong>Pragma 设置特殊实现字段，可能会对请求响应链有多种影响</strong></p><pre><code>Pragma: no-cache</code></pre><p><strong>Proxy-Authorization 为连接代理授权认证信息</strong></p><pre><code>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</code></pre><p><strong>Range 请求部分实体，设置请求实体的字节数范围，具体可以参见HTTP/1.1中的Byte serving</strong></p><pre><code>Range: bytes=500-999</code></pre><p><strong>Referer 设置前一个页面的地址，并且前一个页面中的连接指向当前请求，意思就是如果当前请求是在A页面中发送的，那么referer就是A页面的url地址（轶 事：这个单词正确的拼法应该是”referrer”,但是在很多规范中都拼成了”referer”，所以这个单词也就成为标准用法）</strong></p><pre><code>Referer: http://en.wikipedia.org/wiki/Main_Page</code></pre><p><strong>TE 设置用户代理期望接受的传输编码格式，和响应头中的Transfer-Encoding字段一样</strong></p><pre><code>TE: trailers, deflate</code></pre><p><strong>Upgrade 请求服务端升级协议</strong></p><pre><code>Upgrade: HTTP/2.0, HTTPS/1.3, IRC/6.9, RTA/x11, websocket</code></pre><p><strong>User-Agent 用户代理的字符串值</strong></p><pre><code>User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0</code></pre><p><strong>Via 通知服务器代理请求</strong></p><pre><code>Via: 1.0 fred, 1.1 example.com (Apache/1.1)</code></pre><p><strong>Warning 实体可能会发生的问题的通用警告</strong></p><pre><code>Warning: 199 Miscellaneous warning</code></pre><h3 id="常用非标准请求头字段"><a href="#常用非标准请求头字段" class="headerlink" title="常用非标准请求头字段"></a>常用非标准请求头字段</h3><p><strong>X-Requested-With 标识Ajax请求，大部分js框架发送请求时都会设置它为XMLHttpRequest</strong></p><pre><code>X-Requested-With: XMLHttpRequest</code></pre><p><strong>DNT 请求web应用禁用用户追踪</strong></p><pre><code>DNT: 1 (Do Not Track Enabled)DNT: 0 (Do Not Track Disabled)</code></pre><p><strong>X-Forwarded-For 一个事实标准，用来标识客户端通过HTTP代理或者负载均衡器连接的web服务器的原始IP地址</strong></p><pre><code>X-Forwarded-For: client1, proxy1, proxy2X-Forwarded-For: 129.78.138.66, 129.78.64.103</code></pre><p><strong>X-Forwarded-Host 一个事实标准，用来标识客户端在HTTP请求头中请求的原始host,因为主机名或者反向代理的端口可能与处理请求的原始服务器不同</strong></p><pre><code>X-Forwarded-Host: en.wikipedia.org:8080X-Forwarded-Host: en.wikipedia.org</code></pre><p><strong>X-Forwarded-Proto 一个事实标准，用来标识HTTP原始协议，因为反向代理或者负载均衡器和web服务器可能使用http,但是请求到反向代理使用的是https</strong></p><pre><code>X-Forwarded-Proto: https</code></pre><p><strong>Front-End-Https 微软应用程序和负载均衡器使用的非标准header字段 Front-End-Https: on</strong></p><p><strong>X-Http-Method-Override 请求web应用时，使用header字段中给定的方法（通常是put或者delete）覆盖请求中指定的方法（通常是post）,如果用户代理或者防火墙不支持直接使用put或者delete方法发送请求时，可以使用这个字段</strong></p><pre><code>X-HTTP-Method-Override: DELETE</code></pre><p><strong>X-ATT-DeviceId 允许更简单的解析用户代理在AT&amp;T设备上的MakeModel/Firmware</strong></p><pre><code>X-Att-Deviceid: GT-P7320/P7320XXLPG</code></pre><p><strong>X-Wap-Profile 设置描述当前连接设备的详细信息的xml文件在网络中的位置</strong></p><pre><code>x-wap-profile: http://wap.samsungmobile.com/uaprof/SGH-I777.xml</code></pre><p><strong>Proxy-Connection 早起HTTP版本中的一个误称，现在使用标准的connection字段</strong></p><pre><code>Proxy-Connection: keep-alive</code></pre><p><strong>X-UIDH 服务端深度包检测插入的一个唯一ID标识Verizon Wireless的客户</strong></p><pre><code>X-UIDH: ...</code></pre><p><strong>X-Csrf-Token,X-CSRFToken,X-XSRF-TOKEN 防止跨站请求伪造</strong></p><pre><code>X-Csrf-Token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql</code></pre><p><strong>X-Request-ID,X-Correlation-ID 标识客户端和服务端的HTTP请求</strong></p><pre><code>X-Request-ID: f058ebd6-02f7-4d3f-942e-904344e8cde5</code></pre><h3 id="常用标准响应头字段"><a href="#常用标准响应头字段" class="headerlink" title="常用标准响应头字段"></a>常用标准响应头字段</h3><p><strong>Access-Control-Allow-Origin 指定哪些站点可以参与跨站资源共享</strong></p><pre><code>Access-Control-Allow-Origin: *</code></pre><p><strong>Accept-Patch 指定服务器支持的补丁文档格式，适用于http的patch方法</strong></p><pre><code>Accept-Patch: text/example;charset=utf-8</code></pre><p><strong>Accept-Ranges 服务器通过byte serving支持的部分内容范围类型</strong></p><pre><code>Accept-Ranges: bytes</code></pre><p><strong>Age 对象在代理缓存中暂存的秒数</strong></p><pre><code>Age: 12</code></pre><p><strong>Allow 设置特定资源的有效行为，适用方法不被允许的http 405错误</strong></p><pre><code>Allow: GET, HEAD</code></pre><p><strong>Alt-Svc 服务器使用”Alt-Svc”（Alternative Servicesde的缩写）头标识资源可以通过不同的网络位置或者不同的网络协议获取</strong></p><pre><code>Alt-Svc: h2=&quot;http2.example.com:443&quot;; ma=7200</code></pre><p><strong>Cache-Control 告诉服务端到客户端所有的缓存机制是否可以缓存这个对象，单位是秒</strong></p><pre><code>Cache-Control: max-age=3600</code></pre><p><strong>Connection 设置当前连接和hop-by-hop协议请求字段列表的控制选项</strong></p><pre><code>Connection: close</code></pre><p><strong>Content-Disposition 告诉客户端弹出一个文件下载框，并且可以指定下载文件名</strong></p><pre><code>Content-Disposition: attachment; filename=&quot;fname.ext&quot;</code></pre><p><strong>Content-Encoding 设置数据使用的编码类型</strong></p><pre><code>Content-Encoding: gzip</code></pre><p><strong>Content-Language 为封闭内容设置自然语言或者目标用户语言</strong></p><pre><code>Content-Language: en</code></pre><p><strong>Content-Length 响应体的字节长度</strong></p><pre><code>Content-Length: 348</code></pre><p><strong>Content-Location 设置返回数据的另一个位置</strong></p><pre><code>Content-Location: /index.htm</code></pre><p><strong>Content-MD5 设置基于MD5算法对响应体内容进行Base64二进制编码</strong></p><pre><code>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</code></pre><p><strong>Content-Range 标识响应体内容属于完整消息体中的那一部分</strong></p><pre><code>Content-Range: bytes 21010-47021/47022</code></pre><p><strong>Content-Type 设置响应体的MIME类型</strong></p><pre><code>Content-Type: text/html; charset=utf-8</code></pre><p><strong>Date 设置消息发送的日期和时间</strong></p><pre><code>Date: Tue, 15 Nov 1994 08:12:31 GMT</code></pre><p><strong>ETag 特定版本资源的标识符，通常是消息摘要</strong></p><pre><code>ETag: &quot;737060cd8c284d8af7ad3082f209582d&quot;</code></pre><p><strong>Expires 设置响应体的过期时间</strong></p><pre><code>Expires: Thu, 01 Dec 1994 16:00:00 GMT</code></pre><p><strong>Last-Modified 设置请求对象最后一次的修改日期</strong></p><pre><code>Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT</code></pre><p><strong>Link 设置与其他资源的类型关系</strong></p><pre><code>Link: &lt;/feed&gt;; rel=&quot;alternate&quot;</code></pre><p><strong>Location 在重定向中或者创建新资源时使用</strong></p><pre><code>Location: http://www.w3.org/pub/WWW/People.html</code></pre><p><strong>P3P 以P3P:CP=”your_compact_policy”的格式设置支持P3P(Platform for Privacy Preferences Project)策略，大部分浏览器没有完全支持P3P策略，许多站点设置假的策略内容欺骗支持P3P策略的浏览器以获取第三方cookie的授权</strong></p><pre><code>P3P: CP=&quot;This is not a P3P policy! See http://www.google.com/support/accounts/bin/answer.py?hl=en&amp;answer=151657 for more info.&quot;</code></pre><p><strong>Pragma 设置特殊实现字段，可能会对请求响应链有多种影响</strong></p><pre><code>Pragma: no-cache</code></pre><p><strong>Proxy-Authenticate 设置访问代理的请求权限</strong></p><pre><code>Proxy-Authenticate: Basic</code></pre><p><strong>Public-Key-Pins 设置站点的授权TLS证书</strong></p><pre><code>Public-Key-Pins: max-age=2592000; pin-sha256=&quot;E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=&quot;;</code></pre><p><strong>Refresh “重定向或者新资源创建时使用，在页面的头部有个扩展可以实现相似的功能，并且大部分浏览器都支持</strong><br><code>meta http-equiv=&quot;refresh&quot; content=&quot;5; url=http://example.com/</code> </p><pre><code>Refresh: 5; url=http://www.w3.org/pub/WWW/People.html</code></pre><p><strong>Retry-After 如果实体暂时不可用，可以设置这个值让客户端重试，可以使用时间段（单位是秒）或者HTTP时间</strong></p><pre><code>Example 1: Retry-After: 120Example 2: Retry-After: Fri, 07 Nov 2014 23:59:59 GMT</code></pre><p><strong>Server 服务器WEB名称</strong></p><pre><code>Server: Apache/2.4.1 (Unix)</code></pre><p><strong>Set-Cookie 设置HTTP Cookie</strong></p><pre><code>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</code></pre><p><strong>Status 设置HTTP响应状态</strong></p><pre><code>Status: 200 OK</code></pre><p><strong>Strict-Transport-Security 一种HSTS策略通知HTTP客户端缓存HTTPS策略多长时间以及是否应用到子域</strong></p><pre><code>Strict-Transport-Security: max-age=16070400; includeSubDomains</code></pre><p><strong>Trailer 标识给定的header字段将展示在后续的chunked编码的消息中</strong></p><pre><code>Trailer: Max-Forwards</code></pre><p><strong>Transfer-Encoding 设置传输实体的编码格式，目前支持的格式： chunked, compress, deflate, gzip, identity</strong></p><pre><code>Transfer-Encoding: chunked</code></pre><p><strong>TSV Tracking Status Value，在响应中设置给DNT(do-not-track),可能的取值</strong></p><pre><code>&quot;!&quot; — under construction&quot;?&quot; — dynamic&quot;G&quot; — gateway to multiple parties&quot;N&quot; — not tracking&quot;T&quot; — tracking&quot;C&quot; — tracking with consent&quot;P&quot; — tracking only if consented&quot;D&quot; — disregarding DNT&quot;U&quot; — updatedTSV: ?</code></pre><p><strong>Upgrade 请求客户端升级协议</strong></p><pre><code>Upgrade: HTTP/2.0, HTTPS/1.3, IRC/6.9, RTA/x11, websocket</code></pre><p><strong>Vary 通知下级代理如何匹配未来的请求头已让其决定缓存的响应是否可用而不是重新从源主机请求新的</strong></p><pre><code>Example 1: Vary: *Example 2: Vary: Accept-Language</code></pre><p><strong>Via 通知客户端代理，通过其要发送什么响应</strong></p><pre><code>Via: cache46.l2cn1341[84,206-0,H], cache38.l2c0c801[91,0], kunlun6.cn536[172,304-0,H], kunlun7.cn196[174,0]</code></pre><p><strong>x-cache 是否命中缓存，HIT和MISS</strong></p><pre><code>x-cache: HIT TCP_IMS_HIT dirn:-2:-2</code></pre><p><strong>Warning 实体可能会发生的问题的通用警告</strong></p><pre><code>Warning: 199 Miscellaneous warning</code></pre><p><strong>WWW-Authenticate 标识访问请求实体的身份验证方案</strong></p><pre><code>WWW-Authenticate: Basic</code></pre><p><strong>X-Frame-Options 点击劫持保护：</strong></p><pre><code>deny frame中不渲染sameorigin 如果源不匹配不渲染allow-from 允许指定位置访问allowall 不标准，允许任意位置访问X-Frame-Options: deny</code></pre><h3 id="常用非标准响应头字段"><a href="#常用非标准响应头字段" class="headerlink" title="常用非标准响应头字段"></a>常用非标准响应头字段</h3><p><strong>X-XSS-Protection 过滤跨站脚本</strong></p><pre><code>X-XSS-Protection: 1; mode=block</code></pre><p><strong>Content-Security-Policy, X-Content-Security-Policy,X-WebKit-CSP 定义内容安全策略</strong></p><pre><code>X-WebKit-CSP: default-src &#39;self&#39;</code></pre><p><strong>X-Content-Type-Options 唯一的取值是””,阻止IE在响应中嗅探定义的内容格式以外的其他MIME格式</strong></p><pre><code>X-Content-Type-Options: nosniff</code></pre><p><strong>X-Powered-By 指定支持web应用的技术</strong></p><pre><code>X-Powered-By: PHP/5.4.0</code></pre><p><strong>X-UA-Compatible 推荐首选的渲染引擎来展示内容，通常向后兼容，也用于激活IE中内嵌chrome框架插件</strong><br><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;chrome=1&quot; /&gt;</code> </p><pre><code>X-UA-Compatible: IE=EmulateIE7X-UA-Compatible: IE=edgeX-UA-Compatible: Chrome=1</code></pre><p><strong>X-Content-Duration 提供音视频的持续时间，单位是秒，只有Gecko内核浏览器支持</strong></p><pre><code>X-Content-Duration: 42.666</code></pre><p><strong>Upgrade-Insecure-Requests 标识服务器是否可以处理HTTPS协议</strong></p><pre><code>Upgrade-Insecure-Requests: 1</code></pre><p><strong>X-Request-ID,X-Correlation-ID 标识一个客户端和服务端的请求</strong></p><pre><code>X-Request-ID: f058ebd6-02f7-4d3f-942e-904344e8cde5</code></pre><p><strong>以下是一次客户端请求某网页的过程</strong></p><p><img src="/images/pic/http-cache.png" alt><br>如图通过二次请求对网页状态说明</p><blockquote><ol><li><p>客户端通过浏览器打开某网页，判断本地缓存是否过期。</p></li><li><p>没过期直接从缓存读取并且返回结果。</p></li><li><p>如果过期，服务器算出一个哈希值并通过 ETag 返回给浏览器，浏览器把哈希值和页面同时缓存在本地，当下次再次向服务器请求时，会通过类似 If-None-Match: “etag值” 的请求头把ETag发送给服务器，服务器再次计算页面的哈希值并和浏览器返回的值做比较，如果发现发生了变化就把页面返回给浏览器(200)，如果发现没有变化就给浏览器返回一个304未修改。这样通过控制浏览器端的缓存，可以节省服务器的带宽，因为服务器不需要每次都把全量数据返回给客户端。<br>当未携带Etag时，客户端访问页面，服务器会将页面最后修改时间通过 Last-Modified 标识由服务器发往客户端，客户端记录修改时间，再次请求本地存在的cache页面时，客户端会通过 If-Modified-Since 头将先前服务器端发过来的Last-Modified时间戳发送回去，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回新的内容，如果是最新的，则 返回 304 告诉客户端其本地 cache 的页面是最新的。</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 内核参数详解</title>
      <link href="/2017/11/21/centos-kernel-analysis/"/>
      <url>/2017/11/21/centos-kernel-analysis/</url>
      
        <content type="html"><![CDATA[<h3 id="sysctl-conf-配置参数详解"><a href="#sysctl-conf-配置参数详解" class="headerlink" title="sysctl.conf 配置参数详解"></a>sysctl.conf 配置参数详解</h3><p>所谓Linux服务器内核参数优化，主要是指在Linux系统中针对业务服务应用而进行的系统内核参数调整，优化并无一定的标准。下面以生产环境下Linux常见的内核优化为例进行讲解，仅供参考。</p><pre><code>$ cat /etc/sysctl.conf#打开的文件句柄的数量fs.file-max = 265535#关闭ipv6net.ipv6.conf.all.disable_ipv6 = 1net.ipv6.conf.default.disable_ipv6 = 1# 避免放大攻击net.ipv4.icmp_echo_ignore_broadcasts = 1# 开启恶意icmp错误消息保护net.ipv4.icmp_ignore_bogus_error_responses = 1#关闭路由转发net.ipv4.ip_forward = 0net.ipv4.conf.all.send_redirects = 0net.ipv4.conf.default.send_redirects = 0#开启反向路径过滤net.ipv4.conf.all.rp_filter = 1net.ipv4.conf.default.rp_filter = 1#处理无源路由的包net.ipv4.conf.all.accept_source_route = 0net.ipv4.conf.default.accept_source_route = 0#关闭sysrq功能kernel.sysrq = 0#core文件名中添加pid作为扩展名kernel.core_uses_pid = 1# 开启SYN洪水攻击保护net.ipv4.tcp_syncookies = 1#修改消息队列长度kernel.msgmnb = 65536kernel.msgmax = 65536#设置最大内存共享段大小byteskernel.shmmax = 68719476736kernel.shmall = 4294967296#timewait的数量，默认180000net.ipv4.tcp_max_tw_buckets = 6000net.ipv4.tcp_sack = 1net.ipv4.tcp_window_scaling = 1net.ipv4.tcp_rmem = 4096        87380   4194304net.ipv4.tcp_wmem = 4096        16384   4194304net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216net.core.wmem_max = 16777216#每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目net.core.netdev_max_backlog = 262144#限制仅仅是为了防止简单的DoS 攻击net.ipv4.tcp_max_orphans = 3276800#未收到客户端确认信息的连接请求的最大值net.ipv4.tcp_max_syn_backlog = 262144net.ipv4.tcp_timestamps = 0#内核放弃建立连接之前发送SYNACK 包的数量net.ipv4.tcp_synack_retries = 1#内核放弃建立连接之前发送SYN 包的数量net.ipv4.tcp_syn_retries = 1#启用timewait 快速回收net.ipv4.tcp_tw_recycle = 1#开启重用。允许将TIME-WAIT sockets 重新用于新的TCP 连接net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_mem = 94500000 915000000 927000000net.ipv4.tcp_fin_timeout = 1#当keepalive 起用的时候，TCP 发送keepalive 消息的频度。缺省是2 小时net.ipv4.tcp_keepalive_time = 30#允许系统打开的端口范围net.ipv4.ip_local_port_range = 1024    65000#修改防火墙表大小，默认65536net.netfilter.nf_conntrack_max=655350net.netfilter.nf_conntrack_tcp_timeout_established=1200# 确保无人能修改路由表net.ipv4.conf.all.accept_redirects = 0net.ipv4.conf.default.accept_redirects = 0net.ipv4.conf.all.secure_redirects = 0net.ipv4.conf.default.secure_redirects = 0</code></pre><blockquote><p><code>net.ipv4.tcp_tw_recycle = 1</code> 启用TIME-WAIT状态sockets的快速回收，这个选项不推荐启用。在NAT(Network Address Translation)网络下，会导致大量的TCP连接建立错误。</p><p>我们在一些高并发的 WebServer上，为了端口能够快速回收，常常会打开了 tcp_tw_reccycle 。在关闭 tcp_tw_reccycle 的时候，kernel 是不会检查对端机器的包的时间戳的；而打开了 tcp_tw_reccycle 了，就会检查时间戳，很不幸网络发来的包的时间戳是乱跳的，所以我方的就把带了“倒退”的时间戳的包当作是“recycle的tw连接的重传数据，不是新的请求”，于是丢掉不回包，造成大量丢包。</p></blockquote><blockquote><p>当运行<code>sysctl -p</code>命令时报error: ‘net.ipv4.ip_conntrack_max’ is an unknown key 错时,<br>通过以下命令修正：<br>$ modprobe ip_conntrack<br>$ echo “modprobe ip_conntrack” &gt;&gt; /etc/rc.local</p></blockquote><h3 id="一套生产环境使用过的内核参数"><a href="#一套生产环境使用过的内核参数" class="headerlink" title="一套生产环境使用过的内核参数"></a>一套生产环境使用过的内核参数</h3><ul><li>sysctl.conf文件</li></ul><pre><code>fs.file-max=65535net.ipv4.ip_forward = 0net.ipv4.conf.default.rp_filter = 1net.ipv4.conf.default.accept_source_route = 0net.ipv4.tcp_max_tw_buckets = 6000net.ipv4.ip_local_port_range = 1024 65000net.ipv4.tcp_timestamps = 1net.ipv4.tcp_tw_recycle = 0net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_syncookies = 1kernel.msgmnb = 65536kernel.msgmax = 65536kernel.shmmax = 68719476736kernel.shmall = 4294967296net.ipv4.tcp_max_syn_backlog = 262144net.core.netdev_max_backlog = 262144net.core.somaxconn = 262144net.ipv4.tcp_max_orphans = 262144net.ipv4.tcp_synack_retries = 1net.ipv4.tcp_syn_retries = 1net.ipv4.tcp_fin_timeout = 1net.ipv4.tcp_keepalive_time = 30net.ipv4.tcp_sack = 1net.ipv4.tcp_window_scaling = 1net.ipv4.tcp_rmem = 4096 87380 4194304net.ipv4.tcp_wmem = 4096 16384 4194304net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216net.core.wmem_max = 16777216net.ipv4.tcp_mem = 94500000 915000000 927000000net.nf_conntrack_max = 6553500#redisvm.dirty_ratio=10vm.dirty_background_ratio=5</code></pre><ul><li>禁用SELINUX</li></ul><pre><code>$ vi /etc/sysconfig/selinux  设置为disabled</code></pre><ul><li>同步时间</li></ul><pre><code>$ crontal -l*/20 * * * * /usr/sbin/ntpdate pool.ntp.org &gt; /dev/null 2&gt;&amp;1</code></pre><ul><li>文件描述符数量修改<code>/etc/security/limits.conf</code>文件，在文件末尾添加</li></ul><pre><code>root soft nofile 65535root hard nofile 65535* soft nofile 65535* hard nofile 65535</code></pre><p>还需要修改<code>/etc/security/limits.d</code>下面的conf文件(会覆盖前面的配置信息)，我的是20-nproc.conf</p><pre><code>* soft nproc 65535* hard nproc 65535</code></pre><ul><li>禁用自带的Firewalld防火墙</li></ul><pre><code>systemctl stop firewalld.service 停止firewallsystemctl display firewalld.service 禁止firewall开机自启动</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https证书加密解密原理解析</title>
      <link href="/2017/10/26/https-tls/"/>
      <url>/2017/10/26/https-tls/</url>
      
        <content type="html"><![CDATA[<p>我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取。所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。而HTTPS可以看作是安全的HTTP，你可能听说过关于HTTPS的一些问题，比如什么握手，什么证书，加密之类的等等。<br>HTTPS为何能保障web的安全，其运行原理是怎样的，当我们深入了解下去，其设计的思路对我们其他安全方面的设计也有一定的启发作用。</p><h3 id="与http的区别"><a href="#与http的区别" class="headerlink" title="与http的区别"></a>与http的区别</h3><p>HTTPS其实是有两部分组成：<code>HTTP + SSL / TLS</code> ，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。如下图。</p><pre><code>     HTTP         HTTPS   |-------|     |-------|   |  HTTP |     | HTTPS |   |-------|     |-------|   |  TCP  |     |ssl TLS|   |-------|     |-------|   |  IP   |     |  TCP  |   |-------|     |-------|                 |  IP   |                 |-------|</code></pre><h3 id="HTTPS加密解密证书流程图"><a href="#HTTPS加密解密证书流程图" class="headerlink" title="HTTPS加密解密证书流程图"></a>HTTPS加密解密证书流程图</h3><p><img src="/images/pic/tls.jpg" alt><br>HTTPS流程包含握手和后续的数据传输，握手的目的是为了客户端与服务端协商加密算法等参数。<br>SSL/TLS基本过程是这样的：</p><ul><li>客户端向服务器端所要并验证证书</li><li>双方协定加密算法以及“对话密钥”</li><li>双方采用协商后的“对话密钥”进行加密通信</li></ul><p><strong>整个流程步骤如下：</strong></p><ol><li>客户端发起HTTPS请求<blockquote><p>这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。</p></blockquote></li><li>服务端的配置<blockquote><p>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p></blockquote></li><li>传送证书<blockquote><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p></blockquote></li><li>客户端解析证书<blockquote><p>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p></blockquote></li><li>传送加密信息<blockquote><p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p></blockquote></li><li>服务段解密信息<blockquote><p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p></blockquote></li><li>传输加密后的信息<blockquote><p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原</p></blockquote></li><li>客户端解密信息<blockquote><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</p></blockquote></li></ol><h3 id="HTTPS加密解密证书流程图解释"><a href="#HTTPS加密解密证书流程图解释" class="headerlink" title="HTTPS加密解密证书流程图解释"></a>HTTPS加密解密证书流程图解释</h3><p>HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS/SSL中使用了非对称加密，对称加密以及HASH算法。握手过程的具体描述如下：</p><pre><code>1.浏览器将自己支持的一套加密规则发送给网站。 </code></pre><pre><code>2.网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。 </code></pre><pre><code>3.浏览器获得网站证书之后浏览器要做以下工作： a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。 b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。 c) 使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。 </code></pre><pre><code>4.网站接收浏览器发来的数据之后要做以下的操作： a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。 b) 使用密码加密一段握手消息，发送给浏览器。 </code></pre><pre><code>5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</code></pre><p>这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。另外，HTTPS一般使用的加密与HASH算法如下：</p><pre><code>非对称加密算法：RSA，DSA/DSS 对称加密算法：AES，RC4，3DES HASH算法：MD5，SHA1，SHA256</code></pre>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown格式书写</title>
      <link href="/2017/07/23/markdown-format/"/>
      <url>/2017/07/23/markdown-format/</url>
      
        <content type="html"><![CDATA[<h2 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。<br>类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：</p><pre><code>This is an H1=============This is an H2-------------</code></pre><p>也可以是类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：</p><pre><code># 这是 H1## 这是 H2###### 这是 H6</code></pre><h3 id="区块引用-Blockquotes"><a href="#区块引用-Blockquotes" class="headerlink" title="区块引用 Blockquotes"></a>区块引用 Blockquotes</h3><p>区块引用是使用类似 email 中用 &gt; 的引用方式。例如:</p><pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt;&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</code></pre><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ：</p><pre><code>&gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level.</code></pre><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p><pre><code>&gt; ### 这是一个标题。&gt; &gt; 1.   这是第一行列表项。&gt; 2.   这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Markdown 支持有序列表和无序列表。</p><ul><li>无序列表使用星号、加号或是减号作为列表标记：</li></ul><pre><code>*   Red*   Green*   Blue等同于：+   Red+   Green+   Blue也等同于：-   Red-   Green-   Blue</code></pre><ul><li>有序列表则使用数字接着一个英文句点：</li></ul><pre><code>1.  Bird2.  McHale3.  Parish</code></pre><blockquote><p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：</p><pre><code>* Lorem ipsum dolor sit amet, consectetuer adipiscing elit.  Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,  viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit.  Suspendisse id sem consectetuer libero luctus adipiscing.</code></pre></blockquote><blockquote><p>列表项目可以<code>包含多个段落</code>， 每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p><pre><code>1.  This is a list item with two paragraphs. Lorem ipsum dolor    sit amet, consectetuer adipiscing elit. Aliquam hendrerit    mi posuere lectus.    Vestibulum enim wisi, viverra nec, fringilla in, laoreet    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum    sit amet velit.2. Suspendisse id sem consectetuer libero luctus adipiscing.</code></pre></blockquote><blockquote><p>如果要在列表项目内放进引用，那 &gt; 就需要缩进：</p><pre><code>* A list item with a blockquote:  &gt; This is a blockquote  &gt; inside a list item.</code></pre></blockquote><blockquote><p>如果要放代码区块的话，该<code>区块就需要缩进两次</code>，也就是 8 个空格或是 2 个制表符：</p><pre><code>*   一列表项包含一个列表区块：    &lt;代码写在这&gt;</code></pre></blockquote><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，要在 Markdown 中建立代码区块很简单，只要代码块每行简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p><pre><code>这是一个普通段落：    这是一个代码区块。</code></pre><blockquote><p>markdown也支持html的源码格式，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：</p><pre><code>  &lt;div class=&quot;footer&quot;&gt;       &amp;copy; 2004 Foo Corporation  &lt;/div&gt;</code></pre></blockquote><p>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><pre><code>* * *********- - -</code></pre><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>在markdown中也支持表格格式，格式如下：</p><pre><code>菜单1 | 菜单2 | 菜单3 | 菜单n----: | :---：| :---- | :----内容1 | 内容1 | 内容1 | 内容1内容2 | 内容2 | 内容2 | 内容2内容3 | 内容3 | 内容3 | 内容3</code></pre><p>Markdown 插入的表格，单元格中默认左对齐；表头单元格中的内容会一直居中对齐，可以使用：来设置对齐方式，<code>:---:</code> 居中对齐，<code>---:</code> 右对齐， <code>:---</code> 左对齐，<code>-</code> 的个数不限制。</p><h2 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Markdown 支持两种形式的链接语法： <code>行内式</code> 和<code>参考式</code> 两种形式。<br>不管是哪一种，链接文字都是用 [方括号] 来标记。<br>要建立一个<code>行内式</code> 的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p><pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute.</code></pre><blockquote><p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p><pre><code>See my [About](/about/) page for details.</code></pre></blockquote><p><code>参考式</code> 的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记,接着，在文件的任意处，你可以把这个标记的链接内容定义出来：：</p><pre><code>This is [an example][id] reference-style link.[id]: http://example.com/  &quot;Optional Title Here&quot;</code></pre><p>链接内容定义的形式为：</p><ul><li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li><li>接着一个冒号</li><li>接着一个以上的空格或制表符</li><li>接着链接的网址</li><li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li></ul><p>下面这三种链接的定义都是相同：</p><pre><code>[foo]: http://example.com/  &quot;Optional Title Here&quot;[foo]: http://example.com/  &#39;Optional Title Here&#39;[foo]: http://example.com/  (Optional Title Here)</code></pre><p><strong>请注意：</strong> 有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>Markdown 使用星号<code>（*）和底线（_）作为标记强调字词</code> 的符号，被 <em> 或 _ 包围的字词会被转成用 <em> 标签包围，用`两个 </em> 或 _ <code>包起来的话，则会被转成 &lt;strong&gt;，被</code>三个星号（*）<code>包起来则为倾斜和加粗文字，被两个</code>波浪线（~~）` 包为起来是要在文字上加删除线。例如：</em></p><pre><code>*single asterisks*_single underscores_**double asterisks**__double underscores__***double underscores***~~double underscores~~</code></pre><p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p><p><font color="#FF0000">但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。</font></p><blockquote><p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：</p><pre><code>\*this text is surrounded by literal asterisks\*</code></pre></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>单行短句</li></ul><p>如果要标记一小段行内代码，你可以用反引号把它包起来（<code></code> ），例如：</p><pre><code>Use the `printf()` function.</code></pre><blockquote><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p><pre><code>``There is a literal backtick (`) here.``</code></pre></blockquote><ul><li><p>多行代码块 </p><pre><code>```代码块1代码块2代码块3```</code></pre><p><code>其中&quot;```&quot;也可以用&quot;~~~&quot;代替，且&quot;```&quot;后也支持语言关键字书写，使代码块格式化。例如：```bash</code></p></li></ul><p><em>语言对应关键字请参照本文最末尾。</em></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： <code>行内式</code> 和<code>参考式</code> 。<br>行内式的图片语法看起来像是：</p><pre><code>![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</code></pre><p>详细叙述如下：</p><ul><li>一个惊叹号 !</li><li>接着一个方括号，里面放上图片下面的说明文字，相当于对图片内容的解释。</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。</li></ul><p><code>参考式</code> 的图片语法则长得像这样：</p><pre><code>![Alt text][id][id]: url/to/image  &quot;Optional title attribute&quot;</code></pre><p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p><h3 id="字体和颜色"><a href="#字体和颜色" class="headerlink" title="字体和颜色"></a>字体和颜色</h3><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。但是它<code>本身是不支持修改字体、字号与颜色</code> 等功能的！<br>为了使其修改字体和颜色，我们可以用html语法代替，如：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">face</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>黑体<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是黑体字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">face</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>微软雅黑<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是微软雅黑<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">face</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>STCAIYUN<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是华文彩云<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span>#FF0000</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span>3</span> <span class="token attr-name">face</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>黑体<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这是一行红色3号大小的黑体文本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span>#00ffff</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span>72</span><span class="token punctuation">></span></span>这是16位颜色值表示<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span>gray</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span>72</span><span class="token punctuation">></span></span>也可以用颜色的英文单词表示<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span></code></pre><blockquote><p>Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3。<br>颜色16进制值可以参考：<a href="https://www.114la.com/other/rgb.htm" target="_blank" rel="noopener">https://www.114la.com/other/rgb.htm</a></p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p><pre><code>&lt;http://example.com/&gt;</code></pre><p>Markdown 会转为：</p><pre><code> &lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;</code></pre><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <em> 标签），你可以在星号的前面加上反斜杠：</em></p><pre><code>\*literal asterisks\*</code></pre><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code>\   反斜线`   反引号*   星号_   底线{}  花括号[]  方括号()  括弧#   井字号+   加号-   减号.   英文句点!   惊叹号</code></pre><hr><p>语言关键字</p><table><thead><tr><th style="text-align:center">语言名</th><th style="text-align:center">关键字</th></tr></thead><tbody><tr><td style="text-align:center">Bash</td><td style="text-align:center">bash</td></tr><tr><td style="text-align:center">CoffeeScript</td><td style="text-align:center">coffeescript</td></tr><tr><td style="text-align:center">C++</td><td style="text-align:center">cpp</td></tr><tr><td style="text-align:center">C#</td><td style="text-align:center">cs</td></tr><tr><td style="text-align:center">CSS</td><td style="text-align:center">css</td></tr><tr><td style="text-align:center">Diff</td><td style="text-align:center">diff</td></tr><tr><td style="text-align:center">HTTP</td><td style="text-align:center">http</td></tr><tr><td style="text-align:center">Ini</td><td style="text-align:center">ini</td></tr><tr><td style="text-align:center">Java</td><td style="text-align:center">java</td></tr><tr><td style="text-align:center">JavaScript</td><td style="text-align:center">javascript</td></tr><tr><td style="text-align:center">JSON</td><td style="text-align:center">json</td></tr><tr><td style="text-align:center">XML</td><td style="text-align:center">xml</td></tr><tr><td style="text-align:center">Makefile</td><td style="text-align:center">makefile</td></tr><tr><td style="text-align:center">Markdown</td><td style="text-align:center">markdown</td></tr><tr><td style="text-align:center">Objective-C</td><td style="text-align:center">objectivec</td></tr><tr><td style="text-align:center">Perl</td><td style="text-align:center">perl</td></tr><tr><td style="text-align:center">Python</td><td style="text-align:center">python</td></tr><tr><td style="text-align:center">Ruby</td><td style="text-align:center">ruby</td></tr><tr><td style="text-align:center">SQL</td><td style="text-align:center">sql</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
